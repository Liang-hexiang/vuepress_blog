{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "#/ cd L.H.X Blog Home",
  "home_page_url": "https://lianghexiang.github.io/space/",
  "feed_url": "https://lianghexiang.github.io/space/feed.json",
  "icon": "src/.vuepress/public/images/katongrenwu.png",
  "items": [
    {
      "title": "Spark数据分析导论",
      "url": "https://lianghexiang.github.io/space/posts/pyspark/spark%E5%BF%AB%E9%80%9F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BSpark%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AF%BC%E8%AE%BA.html",
      "id": "https://lianghexiang.github.io/space/posts/pyspark/spark%E5%BF%AB%E9%80%9F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BSpark%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AF%BC%E8%AE%BA.html",
      "content_html": "<h1 id=\"spark数据分析导论\" tabindex=\"-1\"> Spark数据分析导论</h1>\n<div>\n<p>spark快速大数据分析-第一章节</p>\n<p>记录第一章节讲解内容</p>\n</div>\n<h2 id=\"spark是什么\" tabindex=\"-1\"> Spark是什么❓</h2>\n<ol>\n<li>spark 是一个用来实现快速而通用的集群计算的平台。</li>\n<li>Spark能够在内存中进行计算.</li>\n<li>提供丰富的语言接口，包括：Python、Java、Scala</li>\n<li>Spark可以运行在Hadoop集群上。</li>\n</ol>\n<p>​</p>\n<h2 id=\"spark软件栈\" tabindex=\"-1\"> Spark软件栈</h2>\n<blockquote>\n<p>Spark 项目包含多个紧密集成的组件  。Spark 的核心是一个对由很多计算任务组成的、运行在多个工作机器或者是一个计算集群上的应用进行调度、 分发以及监控的计算引擎。</p>\n</blockquote>\n<p>由于Spark 的核心引擎有着速度快和通用的特点  ，Spark 还支持为各种不同应用场景专门设计的高级组件  ，比如</p>\n<p>SQL 和机器学习等  。</p>\n",
      "image": "https://img.tucang.cc/api/image/show/498496728f8ad787045c66c3af161ab1",
      "date_published": "2024-02-01T00:00:00.000Z",
      "date_modified": "2025-02-11T00:29:21.000Z",
      "authors": [
        {
          "name": "梁贺祥"
        }
      ],
      "tags": [
        "技术",
        "IT"
      ]
    },
    {
      "title": "Prompt提示词",
      "url": "https://lianghexiang.github.io/space/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/LLM/llm-prompt%E6%8F%90%E7%A4%BA%E5%8E%9F%E5%88%99.html",
      "id": "https://lianghexiang.github.io/space/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/LLM/llm-prompt%E6%8F%90%E7%A4%BA%E5%8E%9F%E5%88%99.html",
      "content_html": "<h1 id=\"prompt提示词\" tabindex=\"-1\"> Prompt提示词</h1>\n<blockquote>\n<p>如何去使用 Prompt，以充分发挥 LLM 的性能？首先我们需要知道设计 Prompt 的原则，它们是每一个开发者设计 Prompt 所必须知道的基础概念。本章讨论了设计高效 Prompt 的两个关键原则：<strong>编写清晰、具体的指令</strong>和<strong>给予模型充足思考时间</strong>。掌握这两点，对创建可靠的语言模型交互尤为重要。</p>\n</blockquote>\n<p>1️⃣首先，Prompt 需要清晰明确地表达需求，提供充足上下文，使语言模型准确理解我们的意图，就像向一个外星人详细解释人类世界一样。过于简略的 Prompt 往往使模型难以把握所要完成的具体任务。</p>\n<p>2️⃣其次，让语言模型有充足时间推理也极为关键。就像人类解题一样，匆忙得出的结论多有失误。因此 Prompt 应加入逐步推理的要求，给模型留出充分思考时间，这样生成的结果才更准确可靠。</p>\n<h3 id=\"原则一-编写清晰、具体的指令\" tabindex=\"-1\"> 原则一: 编写清晰、具体的指令</h3>\n<blockquote>\n<p>在与语言模型交互时,以<strong>清晰、具体</strong>的方式表达需求。在许多情况下，更长、更复杂的 Prompt 反而会让语言模型更容易抓住关键点，给出符合预期的回复。原因在于，复杂的 Prompt 提供了更丰富的上下文和细节，让模型可以更准确地把握所需的操作和响应方式。</p>\n</blockquote>\n<h4 id=\"_1-使用分隔符清晰地表示输入的不同部分\" tabindex=\"-1\"> 1.使用分隔符清晰地表示输入的不同部分</h4>\n<p>在编写 Prompt 时，我们可以使用各种标点符号作为“分隔符”，将不同的文本部分区分开来。分隔符就像是 Prompt 中的墙，将不同的指令、上下文、输入隔开，避免意外的混淆。你可以选择用 ````，&quot;&quot;&quot;，&lt; &gt;，<tag> </tag>，:` 等做分隔符，只要能明确起到隔断作用即可。</p>\n<p>使用分隔符尤其重要的是可以防止 <strong>提示词注入（Prompt Rejection）</strong>。什么是提示词注入？就是用户输入的文本可能包含与你的预设 Prompt 相冲突的内容，如果不加分隔，这些输入就可能“注入”并操纵语言模型，导致模型产生毫无关联的乱七八糟的输出。</p>\n<p>举个例子，我们使用```分隔文本和指令:</p>\n<div data-ext=\"py\"><pre><code>text <span>=</span> <span><span>f\"\"\"\n您应该提供尽可能清晰、具体的指示，以表达您希望模型执行的任务。\\\n这将引导模型朝向所需的输出，并降低收到无关或不正确响应的可能性。\\\n不要将写清晰的提示词与写简短的提示词混淆。\\\n在许多情况下，更长的提示词可以为模型提供更多的清晰度和上下文信息，从而导致更详细和相关的输出。\n\"\"\"</span></span>\n<span># 需要总结的文本内容</span>\nprompt <span>=</span> <span><span>f\"\"\"\n把用三个反引号括起来的文本总结成一句话。\n```</span><span><span>{</span>text<span>}</span></span><span>```\n\"\"\"</span></span>\n<span># 指令内容，使用 ``` 来分隔指令和待总结的内容</span>\nresponse <span>=</span> get_completion<span>(</span>prompt<span>)</span>\n<span>print</span><span>(</span>response<span>)</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id=\"_2-寻求结构化的输出\" tabindex=\"-1\"> 2.寻求结构化的输出</h4>\n<p>什么是结构化输出? 就是按照某种格式组织的内容，例如JSON、HTML等。这种输出非常适合在代码中进一步解析和处理。</p>\n<p>比如：</p>\n<div data-ext=\"py\"><pre><code><span>\"\"\"\n请生成包括书名、作者和类别的三本虚构的、非真实存在的中文书籍清单，\\\n并以 JSON 格式提供，其中包含以下键:book_id、title、author、genre。\n\"\"\"</span>\nresponse <span>=</span> get_completion<span>(</span>prompt<span>)</span>\n<span>print</span><span>(</span>response<span>)</span>\n<span>{</span>\n  <span>\"books\"</span><span>:</span> <span>[</span>\n    <span>{</span>\n      <span>\"book_id\"</span><span>:</span> <span>1</span><span>,</span>\n      <span>\"title\"</span><span>:</span> <span>\"迷失的时光\"</span><span>,</span>\n      <span>\"author\"</span><span>:</span> <span>\"张三\"</span><span>,</span>\n      <span>\"genre\"</span><span>:</span> <span>\"科幻\"</span>\n    <span>}</span><span>,</span>\n    <span>{</span>\n      <span>\"book_id\"</span><span>:</span> <span>2</span><span>,</span>\n      <span>\"title\"</span><span>:</span> <span>\"幻境之门\"</span><span>,</span>\n      <span>\"author\"</span><span>:</span> <span>\"李四\"</span><span>,</span>\n      <span>\"genre\"</span><span>:</span> <span>\"奇幻\"</span>\n    <span>}</span><span>,</span>\n    <span>{</span>\n      <span>\"book_id\"</span><span>:</span> <span>3</span><span>,</span>\n      <span>\"title\"</span><span>:</span> <span>\"虚拟现实\"</span><span>,</span>\n      <span>\"author\"</span><span>:</span> <span>\"王五\"</span><span>,</span>\n      <span>\"genre\"</span><span>:</span> <span>\"科幻\"</span>\n    <span>}</span>\n  <span>]</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id=\"_3-要求模型检查是否满足条件\" tabindex=\"-1\"> 3. 要求模型检查是否满足条件</h4>\n<p>如果任务包含不一定能满足的假设（条件），我们可以告诉模型先检查这些假设，如果不满足，则会指出并停止执行后续的完整流程。您还可以考虑可能出现的边缘情况及模型的应对，以避免意外的结果或错误发生。</p>\n<h4 id=\"_4-提供少量示例\" tabindex=\"-1\"> 4.提供少量示例</h4>\n<p>&quot;Few-shot&quot; prompting，即在要求模型执行实际任务之前，给模型一两个已完成的样例，让模型了解我们的要求和期望的输出样式。</p>\n<p>例如，在以下的样例中，我们先给了一个对话样例，然后要求模型用同样的隐喻风格回答关于“韧性”的问题。这就是一个少样本样例，它能帮助模型快速抓住我们要的语调和风格。</p>\n<p>利用少样本样例，我们可以轻松“预热”语言模型，让它为新的任务做好准备。这是一个让模型快速上手新任务的有效策略。</p>\n<div data-ext=\"py\"><pre><code>prompt <span>=</span> <span><span>f\"\"\"\n您的任务是以一致的风格回答问题。\n\n&lt;孩子>: 请教我何为耐心。\n\n&lt;祖父母>: 挖出最深峡谷的河流源于一处不起眼的泉眼；最宏伟的交响乐从单一的音符开始；最复杂的挂毯以一根孤独的线开始编织。\n\n&lt;孩子>: 请教我何为韧性。\n\"\"\"</span></span>\nresponse <span>=</span> get_completion<span>(</span>prompt<span>)</span>\n<span>print</span><span>(</span>response<span>)</span>\nresponse <span>-</span><span>></span> <span>\"韧性是一种坚持不懈的品质，就像一棵顽强的树在风雨中屹立不倒。它是面对困难和挑战时不屈不挠的精神，能够适应变化和克服逆境。韧性是一种内在的力量，让我们能够坚持追求目标，即使面临困难和挫折也能坚持不懈地努力。\"</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"原则二-给模型时间去思考\" tabindex=\"-1\"> 原则二 给模型时间去思考</h3>\n<blockquote>\n<p>在设计 Prompt 时，给予语言模型充足的推理时间非常重要。语言模型与人类一样，需要时间来思考并解决复杂问题。如果让语言模型匆忙给出结论，其结果很可能不准确。例如，若要语言模型推断一本书的主题，仅提供简单的书名和一句简介是不足够的。这就像让一个人在极短时间内解决困难的数学题，错误在所难免。</p>\n<p>相反，我们应通过 Prompt 指引语言模型进行深入思考。可以要求其先列出对问题的各种看法，说明推理依据，然后再得出最终结论。在 Prompt 中添加逐步推理的要求，能让语言模型投入更多时间逻辑思维，输出结果也将更可靠准确。</p>\n<p>综上所述，给予语言模型充足的推理时间，是 Prompt Engineering 中一个非常重要的设计原则。这将大大提高语言模型处理复杂问题的效果，也是构建高质量 Prompt 的关键之处。开发者应注意给模型留出思考空间，以发挥语言模型的最大潜力。</p>\n</blockquote>\n<h4 id=\"_1-指定完成任务所需的步骤\" tabindex=\"-1\"> 1.指定完成任务所需的步骤</h4>\n<p>接下来我们将通过给定一个复杂任务，给出完成该任务的一系列步骤，来展示这一策略的效果。</p>\n<p>首先我们描述了杰克和吉尔的故事，并给出提示词执行以下操作：首先，用一句话概括三个反引号限定的文本。第二，将摘要翻译成英语。第三，在英语摘要中列出每个名称。第四，输出包含以下键的 JSON 对象：英语摘要和人名个数。要求输出以换行符分隔。</p>\n<div data-ext=\"py\"><pre><code>text <span>=</span> <span><span>f\"\"\"\n在一个迷人的村庄里，兄妹杰克和吉尔出发去一个山顶井里打水。\\\n他们一边唱着欢乐的歌，一边往上爬，\\\n然而不幸降临——杰克绊了一块石头，从山上滚了下来，吉尔紧随其后。\\\n虽然略有些摔伤，但他们还是回到了温馨的家中。\\\n尽管出了这样的意外，他们的冒险精神依然没有减弱，继续充满愉悦地探索。\n\"\"\"</span></span>\n<span># example 1</span>\nprompt_1 <span>=</span> <span><span>f\"\"\"\n执行以下操作：\n1-用一句话概括下面用三个反引号括起来的文本。\n2-将摘要翻译成英语。\n3-在英语摘要中列出每个人名。\n4-输出一个 JSON 对象，其中包含以下键：english_summary，num_names。\n\n请用换行符分隔您的答案。\n\nText:\n```</span><span><span>{</span>text<span>}</span></span><span>```\n\"\"\"</span></span>\nresponse <span>=</span> get_completion<span>(</span>prompt_1<span>)</span>\n<span>print</span><span>(</span><span>\"prompt 1:\"</span><span>)</span>\n<span>print</span><span>(</span>response<span>)</span>\n\nprompt <span>1</span><span>:</span>\n<span>1</span><span>-</span>两个兄妹在山上打水时发生意外，但最终平安回家。\n<span>2</span><span>-</span>In a charming village<span>,</span> siblings Jack <span>and</span> Jill <span>set</span> off to fetch water <span>from</span> a well on top of a hill<span>.</span> While singing joyfully<span>,</span> they climbed up<span>,</span> but unfortunately<span>,</span> Jack tripped on a stone <span>and</span> rolled down the hill<span>,</span> <span>with</span> Jill following closely behind<span>.</span> Despite some minor injuries<span>,</span> they made it back to their cozy home<span>.</span> Despite the mishap<span>,</span> their adventurous spirit remained undiminished <span>as</span> they continued to explore <span>with</span> delight<span>.</span>\n<span>3</span><span>-</span>Jack<span>,</span> Jill\n<span>4</span><span>-</span><span>{</span><span>\"english_summary\"</span><span>:</span> <span>\"In a charming village, siblings Jack and Jill set off to fetch water from a well on top of a hill. While singing joyfully, they climbed up, but unfortunately, Jack tripped on a stone and rolled down the hill, with Jill following closely behind. Despite some minor injuries, they made it back to their cozy home. Despite the mishap, their adventurous spirit remained undiminished as they continued to explore with delight.\"</span><span>,</span> <span>\"num_names\"</span><span>:</span> <span>2</span><span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上述输出仍然存在一定问题，例如，键“姓名”会被替换为法语（译注：在英文原版中，要求从英语翻译到法语，对应指令第三步的输出为 'Noms:'，为Name的法语，这种行为难以预测，并可能为导出带来困难）</p>\n<div data-ext=\"text\"><pre><code>prompt_2 = f\"\"\"\n1-用一句话概括下面用&lt;>括起来的文本。\n2-将摘要翻译成英语。\n3-在英语摘要中列出每个名称。\n4-输出一个 JSON 对象，其中包含以下键：English_summary，num_names。\n\n请使用以下格式：\n文本：&lt;要总结的文本>\n摘要：&lt;摘要>\n翻译：&lt;摘要的翻译>\n名称：&lt;英语摘要中的名称列表>\n输出 JSON：&lt;带有 English_summary 和 num_names 的 JSON>\n\nText: &lt;{text}>\n\"\"\"\nresponse = get_completion(prompt_2)\nprint(\"\\nprompt 2:\")\nprint(response)\n\nprompt 2:\nSummary: 在一个迷人的村庄里，兄妹杰克和吉尔在山顶井里打水时发生了意外，但他们的冒险精神依然没有减弱，继续充满愉悦地探索。\n\nTranslation: In a charming village, siblings Jack and Jill set off to fetch water from a well on top of a hill. Unfortunately, Jack tripped on a rock and tumbled down the hill, with Jill following closely behind. Despite some minor injuries, they made it back home safely. Despite the mishap, their adventurous spirit remained strong as they continued to explore joyfully.\n\nNames: Jack, Jill\n\nJSON Output: {\"English_summary\": \"In a charming village, siblings Jack and Jill set off to fetch water from a well on top of a hill. Unfortunately, Jack tripped on a rock and tumbled down the hill, with Jill following closely behind. Despite some minor injuries, they made it back home safely. Despite the mishap, their adventurous spirit remained strong as they continued to explore joyfully.\", \"num_names\": 2}\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id=\"_2-指导模型在下结论之前找出一个自己的解法\" tabindex=\"-1\"> 2.指导模型在下结论之前找出一个自己的解法</h4>\n<p>在设计 Prompt 时，我们还可以通过明确指导语言模型进行自主思考，来获得更好的效果。</p>\n<p>假设我们要语言模型判断一个数学问题的解答是否正确。仅仅提供问题和解答是不够的，语言模型可能会匆忙做出错误判断。</p>\n<p>相反，我们可以在 Prompt 中先要求语言模型自己尝试解决这个问题，思考出自己的解法，然后再与提供的解答进行对比，判断正确性。这种先让语言模型自主思考的方式，能帮助它更深入理解问题，做出更准确的判断。</p>\n<p>接下来我们会给出一个问题和一份来自学生的解答，要求模型判断解答是否正确：</p>\n<div data-ext=\"py\"><pre><code>prompt <span>=</span> <span><span>f\"\"\"\n判断学生的解决方案是否正确。\n\n问题:\n我正在建造一个太阳能发电站，需要帮助计算财务。\n\n    土地费用为 100美元/平方英尺\n    我可以以 250美元/平方英尺的价格购买太阳能电池板\n    我已经谈判好了维护合同，每年需要支付固定的10万美元，并额外支付每平方英尺10美元\n    作为平方英尺数的函数，首年运营的总费用是多少。\n\n学生的解决方案：\n设x为发电站的大小，单位为平方英尺。\n费用：\n\n    土地费用：100x\n    太阳能电池板费用：250x\n    维护费用：100,000美元+100x\n    总费用：100x+250x+100,000美元+100x=450x+100,000美元\n\"\"\"</span></span>\nresponse <span>=</span> get_completion<span>(</span>prompt<span>)</span>\n<span>print</span><span>(</span>response<span>)</span>\n\n<span># 学生的解决方案是正确的。他正确地计算了土地费用、太阳能电池板费用和维护费用，并将它们相加得到了总费用。</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>但是注意，学生的解决方案实际上是错误的。（<em>维护费用项100x应为10x，总费用450x应为360x</em>）</p>\n<p>我们可以通过指导模型先自行找出一个解法来解决这个问题。</p>\n<p>在接下来这个 Prompt 中，我们要求模型先自行解决这个问题，再根据自己的解法与学生的解法进行对比，从而判断学生的解法是否正确。同时，我们给定了输出的格式要求。通过拆分任务、明确步骤，让模型有更多时间思考，有时可以获得更准确的结果。在这个例子中，学生的答案是错误的，但如果我们没有先让模型自己计算，那么可能会被误导以为学生是正确的。</p>\n<div data-ext=\"text\"><pre><code>prompt = f\"\"\"\n请判断学生的解决方案是否正确，请通过如下步骤解决这个问题：\n步骤：\n    首先，自己解决问题。\n    然后将您的解决方案与学生的解决方案进行比较，对比计算得到的总费用与学生计算的总费用是否一致，并评估学生的解决方案是否正确。\n    在自己完成问题之前，请勿决定学生的解决方案是否正确。\n使用以下格式：\n\n    问题：问题文本\n    学生的解决方案：学生的解决方案文本\n    实际解决方案和步骤：实际解决方案和步骤文本\n    学生计算的总费用：学生计算得到的总费用\n    实际计算的总费用：实际计算出的总费用\n    学生计算的费用和实际计算的费用是否相同：是或否\n    学生的解决方案和实际解决方案是否相同：是或否\n    学生的成绩：正确或不正确\n\n问题：\n\n    我正在建造一个太阳能发电站，需要帮助计算财务。 \n    - 土地费用为每平方英尺100美元\n    - 我可以以每平方英尺250美元的价格购买太阳能电池板\n    - 我已经谈判好了维护合同，每年需要支付固定的10万美元，并额外支付每平方英尺10美元;\n    作为平方英尺数的函数，首年运营的总费用是多少。\n学生的解决方案：\n\n    设x为发电站的大小，单位为平方英尺。\n    费用：\n    1. 土地费用：100x美元\n    2. 太阳能电池板费用：250x美元\n    3. 维护费用：100,000+100x=10万美元+10x美元\n    总费用：100x美元+250x美元+10万美元+100x美元=450x+10万美元\n实际解决方案和步骤：\n\"\"\"\nresponse = get_completion(prompt)\nprint(response)\n\n实际解决方案和步骤：\n    1. 土地费用：每平方英尺100美元，所以总费用为100x美元。\n    2. 太阳能电池板费用：每平方英尺250美元，所以总费用为250x美元。\n    3. 维护费用：固定费用为10万美元，额外费用为每平方英尺10美元，所以总费用为10万美元+10x美元。\n    4. 总费用：将上述三项费用相加，得到总费用为100x美元+250x美元+10万美元+10x美元=360x+10万美元。\n学生计算的总费用：450x+10万美元\n实际计算的总费用：360x+10万美元\n学生计算的费用和实际计算的费用是否相同：否\n学生的解决方案和实际解决方案是否相同：否\n学生的成绩：不正确\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"三-局限性\" tabindex=\"-1\"> 三 局限性</h3>\n<p><strong>开发大模型相关应用时请务必铭记：</strong></p>\n<p><strong>虚假知识</strong>：模型偶尔会生成一些看似真实实则编造的知识</p>\n<p>在开发与应用语言模型时，需要注意它们可能生成虚假信息的风险。尽管模型经过大规模预训练，掌握了丰富知识，但它实际上并没有<em>完全</em>记住所见的信息，难以准确判断自己的知识边界，可能做出错误推断。若让语言模型描述一个不存在的产品,它可能会自行构造出似是而非的细节。这被称为“幻觉”(Hallucination)，是语言模型的一大缺陷。</p>\n<p>如下示例展示了大模型的幻觉。我们要求告诉我们华为公司生产的 <em>GT Watch 运动手表</em> 产品的信息，事实上，这个公司是真实存在的，但产品是编造的，而模型一本正经地提供了它编造的知识，而且迷惑性很强。</p>\n<div data-ext=\"text\"><pre><code>prompt = f\"\"\"\n告诉我华为公司生产的GT Watch运动手表的相关信息\n\"\"\"\nresponse = get_completion(prompt)\nprint(response)\n\n华为公司生产的GT Watch运动手表是一款智能手表，具有多种功能和特点。以下是相关信息：\n1. 设计和外观：GT Watch采用圆形表盘设计，具有精致的外观和高质量的材料制造。它有多种颜色和表带选择，可以根据个人喜好进行定制。\n2. 显示屏：GT Watch配备了1.39英寸的AMOLED显示屏，具有高清分辨率和良好的可视性。用户可以通过触摸屏幕进行操作和导航。\n3. 运动追踪：GT Watch具有全天候的运动追踪功能，可以监测用户的步数、跑步距离、卡路里消耗和心率等数据。它还支持多种运动模式，如跑步、骑行、游泳等。\n4. 健康监测：GT Watch可以监测用户的心率、血氧饱和度和睡眠质量等健康指标。它还提供健康建议和提醒，帮助用户保持良好的健康状态。\n5. 通知和连接：GT Watch可以与用户的手机进行连接，通过蓝牙技术实现通知推送和电话提醒。用户可以在手表上查看短信、电话和社交媒体通知，无需拿出手机。\n6. 长续航时间：GT Watch具有较长的续航时间，一次充电可以使用数天。它还支持快速充电技术，可以在短时间内充满电。\n7. 其他功能：GT Watch还具有其他功能，如天气预报、闹钟、计时器、计步器等。它还支持NFC支付和音乐控制等便利功能。\n总体而言，华为GT Watch是一款功能强大、外观精致的智能运动手表，适合那些注重健康和运动的用户使用。\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>语言模型生成虚假信息的“幻觉”问题，是使用与开发语言模型时需要高度关注的风险。由于幻觉信息往往令人无法辨别真伪，开发者必须警惕并尽量避免它的产生。</p>\n<p>目前 OpenAI 等公司正在积极研究解决语言模型的幻觉问题。在技术得以进一步改进之前，开发者可以通过Prompt设计减少幻觉发生的可能。例如，可以先让语言模型直接引用文本中的原句，然后再进行解答。这可以追踪信息来源，降低虚假内容的风险。</p>\n<p>综上，语言模型的幻觉问题事关应用的可靠性与安全性。开发者有必要认识到这一缺陷（注：截至2023年7月），并采取Prompt优化等措施予以缓解，以开发出更加可信赖的语言模型应用。这也将是未来语言模型进化的重要方向之一。</p>\n<p><strong>注意</strong>：</p>\n<p>关于反斜杠使用的说明：在本教程中，我们使用反斜杠 \\ 来使文本适应屏幕大小以提高阅读体验，而没有用换行符 \\n 。GPT-3 并不受换行符（newline characters）的影响，但在您调用其他大模型时，需额外考虑换行符是否会影响模型性能。</p>\n",
      "image": "https://img.tucang.cc/api/image/show/6c8acb93bd0fc9dd85006746d572df8f",
      "date_published": "2025-01-03T00:00:00.000Z",
      "date_modified": "2025-02-11T00:29:21.000Z",
      "authors": [],
      "tags": [
        "人工智能"
      ]
    },
    {
      "title": "大语言模型简介",
      "url": "https://lianghexiang.github.io/space/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/LLM/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B.html",
      "id": "https://lianghexiang.github.io/space/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/LLM/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B.html",
      "content_html": "<h1 id=\"大语言模型简介\" tabindex=\"-1\"> 大语言模型简介</h1>\n<h2 id=\"_1-llm理论简介\" tabindex=\"-1\"> 1.LLM理论简介</h2>\n<h3 id=\"一、什么是llm\" tabindex=\"-1\"> 一、什么是LLM</h3>\n<p><strong>大语言模型（LLM，Large Language Model），也称大型语言模型，是一种旨在理解和生成人类语言的人工智能模型</strong>。</p>\n<p>LLM 通常指包含<strong>数百亿（或更多）参数的语言模型</strong>，它们在海量的文本数据上进行训练，从而获得对语言深层次的理解。</p>\n<p>为了探索性能的极限，许多研究人员开始训练越来越庞大的语言模型，例如拥有 <code>1750 亿</code>参数的 <code>GPT-3</code> 和 <code>5400 亿</code>参数的 <code>PaLM</code> 。尽管这些大型语言模型与小型语言模型（例如 <code>3.3 亿</code>参数的 <code>BERT</code> 和 <code>15 亿</code>参数的 <code>GPT-2</code>）使用相似的架构和预训练任务，但它们展现出截然不同的能力，尤其在解决复杂任务时表现出了惊人的潜力，这被称为“<strong>涌现能力</strong>”。以 GPT-3 和 GPT-2 为例，GPT-3 可以通过学习上下文来解决少样本任务，而 GPT-2 在这方面表现较差。因此，科研界给这些庞大的语言模型起了个名字，称之为“大语言模型（LLM）”。LLM 的一个杰出应用就是 <strong>ChatGPT</strong> ，它是 GPT 系列 LLM 用于与人类对话式应用的大胆尝试，展现出了非常流畅和自然的表现。</p>\n<h2 id=\"一、什么是大型语言模型-llm\" tabindex=\"-1\"> 一、什么是大型语言模型（LLM）</h2>\n<h3 id=\"_1-1-大型语言模型-llm-的概念\" tabindex=\"-1\"> 1.1 大型语言模型（LLM）的概念</h3>\n<p><strong>大语言模型（LLM，Large Language Model），也称大型语言模型，是一种旨在理解和生成人类语言的人工智能模型</strong>。</p>\n<p>LLM 通常指包含<strong>数百亿（或更多）参数的语言模型</strong>，它们在海量的文本数据上进行训练，从而获得对语言深层次的理解。目前，国外的知名 LLM 有 GPT-3.5、GPT-4、PaLM、Claude 和 LLaMA 等，国内的有文心一言、讯飞星火、通义千问、ChatGLM、百川等。</p>\n<p>为了探索性能的极限，许多研究人员开始训练越来越庞大的语言模型，例如拥有 <code>1750 亿</code>参数的 <code>GPT-3</code> 和 <code>5400 亿</code>参数的 <code>PaLM</code> 。尽管这些大型语言模型与小型语言模型（例如 <code>3.3 亿</code>参数的 <code>BERT</code> 和 <code>15 亿</code>参数的 <code>GPT-2</code>）使用相似的架构和预训练任务，但它们展现出截然不同的能力，尤其在解决复杂任务时表现出了惊人的潜力，这被称为“<strong>涌现能力</strong>”。以 GPT-3 和 GPT-2 为例，GPT-3 可以通过学习上下文来解决少样本任务，而 GPT-2 在这方面表现较差。因此，科研界给这些庞大的语言模型起了个名字，称之为“大语言模型（LLM）”。LLM 的一个杰出应用就是 <strong>ChatGPT</strong> ，它是 GPT 系列 LLM 用于与人类对话式应用的大胆尝试，展现出了非常流畅和自然的表现。</p>\n<h3 id=\"_1-2-llm-的发展历程\" tabindex=\"-1\"> 1.2 LLM 的发展历程</h3>\n<p>语言建模的研究可以追溯到<code>20 世纪 90 年代</code>，当时的研究主要集中在采用<strong>统计学习方法</strong>来预测词汇，通过分析前面的词汇来预测下一个词汇。但在理解复杂语言规则方面存在一定局限性。</p>\n<p>随后，研究人员不断尝试改进，<code>2003 年</code>深度学习先驱 <strong>Bengio</strong> 在他的经典论文 <code>《A Neural Probabilistic Language Model》</code>中，首次将深度学习的思想融入到语言模型中。强大的<strong>神经网络模型</strong>，相当于为计算机提供了强大的&quot;大脑&quot;来理解语言，让模型可以更好地捕捉和理解语言中的复杂关系。</p>\n<p><code>2018 年</code>左右，<strong>Transformer 架构的神经网络模型</strong>开始崭露头角。通过大量文本数据训练这些模型，使它们能够通过阅读大量文本来深入理解语言规则和模式，就像让计算机阅读整个互联网一样，对语言有了更深刻的理解，极大地提升了模型在各种自然语言处理任务上的表现。</p>\n<p>与此同时，研究人员发现，随着<strong>语言模型规模的扩大（增加模型大小或使用更多数据）</strong>，模型展现出了一些惊人的能力，在各种任务中的表现均显著提升。这一发现标志着大型语言模型（LLM）时代的开启。</p>\n<h3 id=\"_1-3-常见的-llm-模型\" tabindex=\"-1\"> 1.3 常见的 LLM 模型</h3>\n<p>大语言模型的发展历程虽然只有短短不到五年的时间，但是发展速度相当惊人，截止 2023 年 6 月，国内外有超过百种大模型相继发布。下图按照时间线给出了 2019 年至 2023 年 6 月比较有影响力并且模型参数量超过 100 亿的大语言模型：</p>\n<figure><img src=\"https://datawhalechina.github.io/figures/C1-1-LLMs_0623_final.png\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<p>（该图来源于参考内容 [<a href=\"https://arxiv.org/abs/2303.18223\" target=\"_blank\" rel=\"noopener noreferrer\">1</a>]）</p>\n<p>接下来我们主要介绍几个国内外常见的大模型（包括开源和闭源）</p>\n<h4 id=\"_1-3-1-闭源-llm-未公开源代码\" tabindex=\"-1\"> 1.3.1 闭源 LLM (未公开源代码)</h4>\n<h5 id=\"_1-3-1-1-gpt-系列\" tabindex=\"-1\"> 1.3.1.1 GPT 系列</h5>\n<blockquote>\n<p><a href=\"https://platform.openai.com/docs/models\" target=\"_blank\" rel=\"noopener noreferrer\">OpenAI 模型介绍</a></p>\n</blockquote>\n<p><strong>OpenAI</strong> 公司在 <code>2018 年</code>提出的 <strong>GPT（Generative Pre-Training）</strong> 模型是典型的 <code>生成式预训练语言模型</code> 之一。</p>\n<p>GPT 模型的基本原则是<strong>通过语言建模将世界知识压缩到仅解码器 (decoder-only) 的 Transformer 模型中</strong>，这样它就可以恢复(或记忆)世界知识的语义，并充当通用任务求解器。它能够成功的两个关键点：</p>\n<ul>\n<li>训练能够准确预测下一个单词的 decoder-only 的 Transformer 语言模型</li>\n<li>扩展语言模型的大小</li>\n</ul>\n<p>OpenAI 在 LLM 上的研究大致可以分为以下几个阶段：</p>\n<figure><img src=\"https://datawhalechina.github.io/llm-universe/figures/C1-1-GPT_series.png\" alt=\"GPT 阶段\" tabindex=\"0\" loading=\"lazy\"><figcaption>GPT 阶段</figcaption></figure>\n<p>接下来，我们将从模型规模、特点等方面，介绍大家熟知的 ChatGPT 与 GPT4：</p>\n<h6 id=\"_1-3-1-1-1-chatgpt-https-datawhalechina-github-io-llm-universe-c1-1-大语言模型-llm-理论简介-id-13111-chatgpt\" tabindex=\"-1\"> [1.3.1.1.1 ChatGPT](<a href=\"https://datawhalechina.github.io/llm-universe/#/C1/1.%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B\" target=\"_blank\" rel=\"noopener noreferrer\">https://datawhalechina.github.io/llm-universe/#/C1/1.大语言模型</a> LLM 理论简介?id=_13111-chatgpt)</h6>\n<blockquote>\n<p><a href=\"https://chat.openai.com/\" target=\"_blank\" rel=\"noopener noreferrer\">ChatGPT 使用地址</a></p>\n</blockquote>\n<p><code>2022 年 11 月</code>，<strong>OpenAI</strong> 发布了基于 GPT 模型（GPT-3.5 和 GPT-4） 的<strong>会话应用 ChatGPT</strong>。由于与人类交流的出色能力，ChatGPT 自发布以来就引发了人工智能社区的兴奋。ChatGPT 是基于强大的 GPT 模型开发的，具有特别优化的会话能力。</p>\n<p>ChatGPT 从本质上来说是一个 LLM 应用，是基于基座模型开发出来的，与基座模型有本质的区别。其支持 GPT-3.5 和 GPT-4 两个版本。</p>\n<figure><img src=\"https://datawhalechina.github.io/llm-universe/figures/C1-1-ChatGPT.png\" alt=\"ChatGPT 界面\" tabindex=\"0\" loading=\"lazy\"><figcaption>ChatGPT 界面</figcaption></figure>\n<p>现在的 ChatGPT 支持最长达 32,000 个字符，知识截止日期是 2021 年 9 月，它可以执行各种任务，包括<strong>代码编写、数学问题求解、写作建议</strong>等。ChatGPT 在与人类交流方面表现出了卓越的能力：拥有丰富的知识储备，对数学问题进行推理的技能，在多回合对话中准确追踪上下文，并且与人类安全使用的价值观非常一致。后来，ChatGPT 支持插件机制，这进一步扩展了 ChatGPT 与现有工具或应用程序的能力。到目前为止，它似乎是人工智能历史上最强大的聊天机器人。ChatGPT 的推出对未来的人工智能研究具有重大影响，它为探索类人人工智能系统提供了启示。</p>\n<h6 id=\"_1-3-1-1-2-gpt-4\" tabindex=\"-1\"> 1.3.1.1.2 GPT-4</h6>\n<p><code>2023 年 3 月</code>发布的 GPT-4，它将<strong>文本输入扩展到多模态信号</strong>。GPT3.5 拥有 1750 亿 个参数，而 GPT4 的参数量官方并没有公布，但有相关人员猜测，GPT-4 在 120 层中总共包含了 1.8 万亿参数，也就是说，GPT-4 的规模是 GPT-3 的 10 倍以上。因此，GPT-4 比 GPT-3.5 <strong>解决复杂任务的能力更强，在许多评估任务上表现出较大的性能提升</strong>。</p>\n<p>最近的一项研究通过对人为生成的问题进行定性测试来研究 GPT-4 的能力，这些问题包含了各种各样的困难任务，并表明 GPT-4 可以比之前的 GPT 模型(如 GPT3.5 )实现更优越的性能。此外，由于六个月的迭代校准(在 RLHF 训练中有额外的安全奖励信号)，GPT-4 对恶意或挑衅性查询的响应更安全，并应用了一些干预策略来缓解 LLM 可能出现的问题，如幻觉、隐私和过度依赖。</p>\n<blockquote>\n<p>注意：2023 年 11 月 7 日， OpenAI 召开了首个开发者大会，会上推出了最新的大语言模型 GPT-4 Turbo，Turbo 相当于进阶版。它将上下文长度扩展到 128k，相当于 300 页文本，并且训练知识更新到 2023 年 4 月</p>\n</blockquote>\n<p>GPT3.5 是免费的，而 GPT-4 是收费的。需要开通 plus 会员 20 美元/月。</p>\n<p><code>2024 年 5 月 14 日</code>，新一代旗舰生成模型 <strong>GPT-4o</strong> 正式发布。GPT-4o 具备了对文本、语音、图像三种模态的深度理解能力，反应迅速且富有情感色彩，极具人性化。而且 GPT-4o 是完全免费的，虽然每天的免费使用次数是有限的。</p>\n<p>通常我们可以调用模型 API 来开发自己的应用，主流模型 <a href=\"https://openai.com/pricing\" target=\"_blank\" rel=\"noopener noreferrer\">API 对比</a>如下：</p>\n<table>\n<thead>\n<tr>\n<th>语言模型名称</th>\n<th>上下文长度</th>\n<th>特点</th>\n<th>input 费用($/million tokens)</th>\n<th>output 费用($/ 1M tokens)</th>\n<th>知识截止日期</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GPT-3.5-turbo-0125</td>\n<td>16k</td>\n<td>经济，专门对话</td>\n<td>0.5</td>\n<td>1.5</td>\n<td>2021 年 9 月</td>\n</tr>\n<tr>\n<td>GPT-3.5-turbo-instruct</td>\n<td>4k</td>\n<td>指令模型</td>\n<td>1.5</td>\n<td>2</td>\n<td>2021 年 9 月</td>\n</tr>\n<tr>\n<td>GPT-4</td>\n<td>8k</td>\n<td>性能更强</td>\n<td>30</td>\n<td>60</td>\n<td>2021 年 9 月</td>\n</tr>\n<tr>\n<td>GPT-4-32k</td>\n<td>32k</td>\n<td>性能强，长上下文</td>\n<td>60</td>\n<td>120</td>\n<td>2021 年 9 月</td>\n</tr>\n<tr>\n<td>GPT-4-turbo</td>\n<td>128k</td>\n<td>性能更强</td>\n<td>10</td>\n<td>30</td>\n<td>2023 年 12 月</td>\n</tr>\n<tr>\n<td>GPT-4o</td>\n<td>128k</td>\n<td>性能最强，速度更快</td>\n<td>5</td>\n<td>15</td>\n<td>2023 年 10 月</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>Embedding 模型名称</th>\n<th>维度</th>\n<th>特点</th>\n<th>费用($/ 1M tokens)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>text-embedding-3-small</td>\n<td>512/1536</td>\n<td>较小</td>\n<td>0.02</td>\n</tr>\n<tr>\n<td>text-embedding-3-large</td>\n<td>256/1024/3072</td>\n<td>较大</td>\n<td>0.13</td>\n</tr>\n<tr>\n<td>ada v2</td>\n<td>1536</td>\n<td>传统</td>\n<td>0.1</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"_1-3-1-2-claude-系列\" tabindex=\"-1\"> 1.3.1.2 Claude 系列</h5>\n<p>Claude 系列模型是由 OpenAI 离职人员创建的 <strong>Anthropic</strong> 公司开发的闭源语言大模型。</p>\n<blockquote>\n<p><a href=\"https://claude.ai/chats\" target=\"_blank\" rel=\"noopener noreferrer\">Claude 使用地址</a></p>\n</blockquote>\n<p>最早的 <strong>Claude</strong> 于 <code>2023 年 3 月 15 日</code>发布，在 2023 年 7 月 11 日，更新至 <strong>Claude-2</strong>， 并在 <code>2024 年 3 月 4 日</code>更新至 <strong>Claude-3</strong>。</p>\n<p>Claude 3 系列包括三个不同的模型，分别是 Claude 3 Haiku、Claude 3 Sonnet 和 Claude 3 Opus，它们的能力依次递增，旨在满足不同用户和应用场景的需求。</p>\n<table>\n<thead>\n<tr>\n<th>模型名称</th>\n<th>上下文长度</th>\n<th>特点</th>\n<th>input 费用($/1M tokens)</th>\n<th>output 费用($/1M tokens)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Claude 3 Haiku</td>\n<td>200k</td>\n<td>速度最快</td>\n<td>0.25</td>\n<td>1.25</td>\n</tr>\n<tr>\n<td>Claude 3 Sonnet</td>\n<td>200k</td>\n<td>平衡</td>\n<td>3</td>\n<td>15</td>\n</tr>\n<tr>\n<td>Claude 3 Opus</td>\n<td>200k</td>\n<td>性能最强</td>\n<td>15</td>\n<td>75</td>\n</tr>\n</tbody>\n</table>\n<figure><img src=\"https://datawhalechina.github.io/llm-universe/figures/C1-1-Claude.png\" alt=\"Claude 界面\" tabindex=\"0\" loading=\"lazy\"><figcaption>Claude 界面</figcaption></figure>\n<h5 id=\"_1-3-1-1-3-palm-gemini-系列\" tabindex=\"-1\"> 1.3.1.1.3 PaLM/Gemini 系列</h5>\n<p><strong>PaLM 系列</strong>语言大模型由 <strong>Google</strong> 开发。其初始版本于 <code>2022 年 4 月</code>发布，并在 2023 年 3 月公开了 API。2023 年 5 月，Google 发布了 <strong>PaLM 2</strong>，<code>2024 年 2 月 1 日</code>，Google 将 Bard(之前发布的对话应用) 的底层大模型驱动由 PaLM2 更改为 <strong>Gemini</strong>，同时也将原先的 Bard 更名为 <strong>Gemini</strong>。</p>\n<blockquote>\n<p><a href=\"https://ai.google/discover/palm2/\" target=\"_blank\" rel=\"noopener noreferrer\">PaLM 官方地址</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://gemini.google.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Gemini 使用地址</a></p>\n</blockquote>\n<p>目前的 Gemini 是第一个版本，即 Gemini 1.0，根据参数量不同分为 Ultra, Pro 和 Nano 三个版本。</p>\n<p>以下窗口是 Gemini 的界面:</p>\n<figure><img src=\"https://datawhalechina.github.io/llm-universe/figures/C1-1-Gemini.png\" alt=\"Gemini 界面\" tabindex=\"0\" loading=\"lazy\"><figcaption>Gemini 界面</figcaption></figure>\n<h5 id=\"_1-3-1-1-4-文心一言\" tabindex=\"-1\"> 1.3.1.1.4 文心一言</h5>\n<blockquote>\n<p><a href=\"https://yiyan.baidu.com/\" target=\"_blank\" rel=\"noopener noreferrer\">文心一言使用地址</a></p>\n</blockquote>\n<p><strong>文心一言是基于百度文心大模型的知识增强语言大模型</strong>，于 <code>2023 年 3 月</code>在国内率先开启邀测。文心一言的基础模型文心大模型于 2019 年发布 1.0 版，现已更新到 <strong>4.0</strong> 版本。更进一步划分，文心大模型包括 NLP 大模型、CV 大模型、跨模态大模型、生物计算大模型、行业大模型。中文能力相对来说非常不错的闭源模型。</p>\n<p>文心一言网页版分为<strong>免费版</strong>和<strong>专业版</strong>。</p>\n<ul>\n<li>免费版使用文心 3.5 版本，已经能够满足个人用户或小型企业的大部分需求。</li>\n<li>专业版使用文心 4.0 版本。定价为 59.9 元/月，连续包月优惠价为 49.9 元/月</li>\n</ul>\n<p>同时也可以使用 API 进行调用（<a href=\"https://console.bce.baidu.com/qianfan/chargemanage/list\" target=\"_blank\" rel=\"noopener noreferrer\">计费详情</a>）。</p>\n<p>以下是文心一言的使用界面：</p>\n<figure><img src=\"https://datawhalechina.github.io/llm-universe/figures/C1-1-yiyan.png\" alt=\"文心一言界面\" tabindex=\"0\" loading=\"lazy\"><figcaption>文心一言界面</figcaption></figure>\n<h5 id=\"_1-3-1-1-5-星火大模型\" tabindex=\"-1\"> 1.3.1.1.5 星火大模型</h5>\n<blockquote>\n<p><a href=\"https://xinghuo.xfyun.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">星火大模型使用地址</a></p>\n</blockquote>\n<p><strong>讯飞星火认知大模型</strong>是<strong>科大讯飞</strong>发布的语言大模型，支持多种自然语言处理任务。该模型于 <code>2023 年 5 月</code>首次发布，后续经过多次升级。<code>2023 年 10 月</code>，讯飞发布了<strong>讯飞星火认知大模型 V3.0</strong>。<code>2024 年 1 月</code>，讯飞发布了<strong>讯飞星火认知大模型 V3.5</strong>，在语言理解，文本生成，知识问答等七个方面进行了升级，并且支持 system 指令，插件调用等多项功能。</p>\n<figure><img src=\"https://datawhalechina.github.io/llm-universe/figures/C1-1-xunfei.jpg\" alt=\"讯飞发布会\" tabindex=\"0\" loading=\"lazy\"><figcaption>讯飞发布会</figcaption></figure>\n<p>以下是讯飞星火的使用界面：</p>\n<figure><img src=\"https://datawhalechina.github.io/llm-universe/figures/C1-1-xinghuo.png\" alt=\"讯飞星火界面\" tabindex=\"0\" loading=\"lazy\"><figcaption>讯飞星火界面</figcaption></figure>\n<h4 id=\"_1-3-2-开源-llm\" tabindex=\"-1\"> 1.3.2. 开源 LLM]</h4>\n<h5 id=\"_1-3-2-1-llama-系列\" tabindex=\"-1\"> 1.3.2.1 LLaMA 系列</h5>\n<blockquote>\n<p><a href=\"https://llama.meta.com/\" target=\"_blank\" rel=\"noopener noreferrer\">LLaMA 官方地址</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/facebookresearch/llama\" target=\"_blank\" rel=\"noopener noreferrer\">LLaMA 开源地址</a></p>\n</blockquote>\n<p><strong>LLaMA 系列模型</strong>是 <strong>Meta</strong> 开源的一组参数规模 <strong>从 7B 到 70B</strong> 的基础语言模型。LLaMA 于<code>2023 年 2 月</code>发布，2023 年 7 月发布了 LLaMA2 模型，并于 <code>2024 年 4 月 18 日</code>发布了 <strong>LLaMA3</strong> 模型。它们都是在数万亿个字符上训练的，展示了如何<strong>仅使用公开可用的数据集来训练最先进的模型</strong>，而不需要依赖专有或不可访问的数据集。这些数据集包括 Common Crawl、Wikipedia、OpenWebText2、RealNews、Books 等。LLaMA 模型使用了<strong>大规模的数据过滤和清洗技术</strong>，以提高数据质量和多样性，减少噪声和偏见。LLaMA 模型还使用了高效的<strong>数据并行</strong>和<strong>流水线并行</strong>技术，以加速模型的训练和扩展。特别地，LLaMA 13B 在 CommonsenseQA 等 9 个基准测试中超过了 GPT-3 (175B)，而 <strong>LLaMA 65B 与最优秀的模型 Chinchilla-70B 和 PaLM-540B 相媲美</strong>。LLaMA 通过使用更少的字符来达到最佳性能，从而在各种推理预算下具有优势。</p>\n<p>与 GPT 系列相同，LLaMA 模型也采用了 <strong>decoder-only</strong> 架构，同时结合了一些前人工作的改进：</p>\n<ul>\n<li><code>Pre-normalization 正则化</code>：为了提高训练稳定性，LLaMA 对每个 Transformer 子层的输入进行了 RMSNorm 归一化，这种归一化方法可以避免梯度爆炸和消失的问题，提高模型的收敛速度和性能；</li>\n<li><code>SwiGLU 激活函数</code>：将 ReLU 非线性替换为 SwiGLU 激活函数，增加网络的表达能力和非线性，同时减少参数量和计算量；</li>\n<li><code>旋转位置编码（RoPE，Rotary Position Embedding）</code>：模型的输入不再使用位置编码，而是在网络的每一层添加了位置编码，RoPE 位置编码可以有效地捕捉输入序列中的相对位置信息，并且具有更好的泛化能力。</li>\n</ul>\n<p><strong>LLaMA3</strong> 在 LLaMA 系列模型的基础上进行了改进，提高了模型的性能和效率：</p>\n<ul>\n<li><code>更多的训练数据量</code>：LLaMA3 在 15 万亿个 token 的数据上进行预训练，相比 LLaMA2 的训练数据量增加了 7 倍，且代码数据增加了 4 倍。LLaMA3 能够接触到更多的文本信息，从而提高了其理解和生成文本的能力。</li>\n<li><code>更长的上下文长度</code>：LLaMA3 的上下文长度增加了一倍，从 LLaMA2 的 4096 个 token 增加到了 8192。这使得 LLaMA3 能够处理更长的文本序列，改善了对长文本的理解和生成能力。</li>\n<li><code>分组查询注意力（GQA，Grouped-Query Attention）</code>：通过将查询（query）分组并在组内共享键（key）和值（value），减少了计算量，同时保持了模型性能，提高了大型模型的推理效率（LLaMA2 只有 70B 采用）。</li>\n<li><code>更大的词表</code>：LLaMA3 升级为了 128K 的 tokenizer，是前两代 32K 的 4 倍，这使得其语义编码能力得到了极大的增强，从而显著提升了模型的性能。</li>\n</ul>\n<h5 id=\"_1-3-2-2-通义千问\" tabindex=\"-1\"> 1.3.2.2 通义千问</h5>\n<blockquote>\n<p><a href=\"https://tongyi.aliyun.com/\" target=\"_blank\" rel=\"noopener noreferrer\">通义千问使用地址</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/QwenLM/Qwen2\" target=\"_blank\" rel=\"noopener noreferrer\">通义千问开源地址</a></p>\n</blockquote>\n<p><strong>通义千问由阿里巴巴基于“通义”大模型研发</strong>，于 <code>2023 年 4 月</code>正式发布。2023 年 9 月，阿里云开源了 Qwen（通义千问）系列工作。2024 年 2 月 5 日，开源了 <strong>Qwen1.5</strong>（Qwen2 的测试版）。并于 <code>2024 年 6 月 6 日</code>正式开源了 <strong>Qwen2</strong>。 Qwen2 是一个 <strong>decoder-Only</strong> 的模型，采用 <code>SwiGLU 激活</code>、<code>RoPE</code>、<code>GQA</code>的架构。中文能力相对来说非常不错的开源模型。</p>\n<p>目前，已经开源了 5 种模型大小：<strong>0.5B、1.5B、7B、72B 的 Dense 模型和 57B (A14B)的 MoE 模型</strong>；所有模型均支持长度为 <strong>32768 token</strong> 的上下文。并将 Qwen2-7B-Instruct 和 Qwen2-72B-Instruct 的上下文长度扩展至 <strong>128K token</strong>。</p>\n<p>以下是通义千问的使用界面： <img src=\"https://datawhalechina.github.io/llm-universe/figures/C1-1-qwen.png\" alt=\"通义千问界面\" loading=\"lazy\"></p>\n<h5 id=\"_1-3-2-3-glm-系列\" tabindex=\"-1\"> 1.3.2.3 GLM 系列</h5>\n<blockquote>\n<p><a href=\"https://chatglm.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">ChatGLM 使用地址</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/THUDM/GLM-4\" target=\"_blank\" rel=\"noopener noreferrer\">ChatGLM 开源地址</a></p>\n</blockquote>\n<p><strong>GLM 系列模型</strong>是<strong>清华大学和智谱 AI 等</strong>合作研发的语言大模型。2023 年 3 月 发布了 <strong>ChatGLM</strong>。6 月发布了 <strong>ChatGLM 2</strong>。10 月推出了 <strong>ChatGLM3</strong>。2024 年 1 月 16 日 发布了 <strong>GLM4</strong>，并于 <code>2024 年 6 月 6 日</code>正式开源。</p>\n<p><strong>GLM-4-9B-Chat</strong> 支持多轮对话的同时，还具备网页浏览、代码执行、自定义工具调用（Function Call）和长文本推理（支持最大 <strong>128K</strong> 上下文）等功能。</p>\n<p>开源了<code>对话模型</code> <strong>GLM-4-9B-Chat</strong>、<code>基础模型</code> <strong>GLM-4-9B</strong>、<code>长文本对话模型</code> <strong>GLM-4-9B-Chat-1M</strong>（支持 1M 上下文长度）、<code>多模态模型</code><strong>GLM-4V-9B</strong> 等全面对标 OpenAI：</p>\n<figure><img src=\"https://datawhalechina.github.io/llm-universe/figures/C1-1-chatglm_vs_openai.png\" alt=\"chatglm VS openai\" tabindex=\"0\" loading=\"lazy\"><figcaption>chatglm VS openai</figcaption></figure>\n<p>以下是智谱清言的使用界面：</p>\n<figure><img src=\"https://datawhalechina.github.io/llm-universe/figures/C1-1-chatglm.png\" alt=\"智谱清言界面\" tabindex=\"0\" loading=\"lazy\"><figcaption>智谱清言界面</figcaption></figure>\n<h5 id=\"_1-3-2-4-baichuan-系列\" tabindex=\"-1\"> 1.3.2.4 Baichuan 系列</h5>\n<blockquote>\n<p><a href=\"https://www.baichuan-ai.com/chat\" target=\"_blank\" rel=\"noopener noreferrer\">百川使用地址</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/baichuan-inc\" target=\"_blank\" rel=\"noopener noreferrer\">百川开源地址</a></p>\n</blockquote>\n<p><strong>Baichuan</strong> 是由<strong>百川智能</strong>开发的<strong>开源可商用</strong>的语言大模型。其基于<strong>Transformer 解码器架构（decoder-only）</strong>。</p>\n<p>2023 年 6 月 15 日发布了 <strong>Baichuan-7B</strong> 和 <strong>Baichuan-13B</strong>。百川同时开源了<strong>预训练</strong>和<strong>对齐</strong>模型，<code>预训练模型是面向开发者的“基座”</code>，而<code>对齐模型则面向广大需要对话功能的普通用户</code>。</p>\n<p><strong>Baichuan2</strong> 于 <code>2023年 9 月 6 日</code>推出。发布了 <strong>7B、13B</strong> 的 <strong>Base</strong> 和 <strong>Chat</strong> 版本，并提供了 Chat 版本的 <strong>4bits 量化</strong>。</p>\n<p><code>2024 年 1 月 29 日</code> 发布了 <strong>Baichuan 3</strong>。但是<strong>目前还没有开源</strong>。</p>\n<p>以下是百川大模型的使用界面： <img src=\"https://datawhalechina.github.io/llm-universe/figures/C1-1-baichuan.png\" alt=\"百川界面\" loading=\"lazy\"></p>\n<h2 id=\"二、llm-的能力与特点\" tabindex=\"-1\"> 二、LLM 的能力与特点</h2>\n<h3 id=\"_2-1-llm-的能力\" tabindex=\"-1\"> 2.1 LLM 的能力</h3>\n<h4 id=\"_2-1-1-涌现能力-emergent-abilities\" tabindex=\"-1\"> 2.1.1 涌现能力（emergent abilities）</h4>\n<p>区分大语言模型（LLM）与以前的预训练语言模型（PLM）最显著的特征之一是它们的 <code>涌现能力</code> 。涌现能力是一种令人惊讶的能力，它在小型模型中不明显，但在大型模型中特别突出。类似物理学中的相变现象，涌现能力就像是模型性能随着规模增大而迅速提升，超过了随机水平，也就是我们常说的<strong>量变引起质变</strong>。</p>\n<p>涌现能力可以与某些复杂任务有关，但我们更关注的是其通用能力。接下来，我们简要介绍三个 LLM 典型的涌现能力：</p>\n<ol>\n<li><strong>上下文学习</strong>：上下文学习能力是由 GPT-3 首次引入的。这种能力允许语言模型在提供自然语言指令或多个任务示例的情况下，通过理解上下文并生成相应输出的方式来执行任务，而无需额外的训练或参数更新。</li>\n<li><strong>指令遵循</strong>：通过使用自然语言描述的多任务数据进行微调，也就是所谓的 <code>指令微调</code>。LLM 被证明在使用指令形式化描述的未见过的任务上表现良好。这意味着 LLM 能够根据任务指令执行任务，而无需事先见过具体示例，展示了其强大的泛化能力。</li>\n<li><strong>逐步推理</strong>：小型语言模型通常难以解决涉及多个推理步骤的复杂任务，例如数学问题。然而，LLM 通过采用 <code>思维链（CoT, Chain of Thought）</code> 推理策略，利用包含中间推理步骤的提示机制来解决这些任务，从而得出最终答案。据推测，这种能力可能是通过对代码的训练获得的。</li>\n</ol>\n<p>这些涌现能力让 LLM 在处理各种任务时表现出色，使它们成为了解决复杂问题和应用于多领域的强大工具。</p>\n<h4 id=\"_2-1-2-作为基座模型支持多元应用的能力\" tabindex=\"-1\"> 2.1.2 作为基座模型支持多元应用的能力</h4>\n<p>在 2021 年，斯坦福大学等多所高校的研究人员提出了基座模型（foundation model）的概念，清晰了预训练模型的作用。这是一种全新的 AI 技术范式，借助于海量无标注数据的训练，获得可以适用于大量下游任务的大模型（单模态或者多模态）。这样，<strong>多个应用可以只依赖于一个或少数几个大模型进行统一建设</strong>。</p>\n<p>大语言模型是这个新模式的典型例子，使用统一的大模型可以极大地提高研发效率。相比于每次开发单个模型的方式，这是一项本质上的进步。大型模型不仅可以缩短每个具体应用的开发周期，减少所需人力投入，也可以基于大模型的推理、常识和写作能力，获得更好的应用效果。因此，大模型可以成为 AI 应用开发的大一统基座模型，这是一个一举多得、全新的范式，值得大力推广。</p>\n<h4 id=\"_2-1-3-支持对话作为统一入口的能力\" tabindex=\"-1\"> 2.1.3 支持对话作为统一入口的能力</h4>\n<p>让大语言模型真正火爆的契机，是基于对话聊天的 <strong>ChatGPT</strong>。业界很早就发现了用户对于对话交互的特殊偏好，陆奇在微软期间，就于 2016 年推进过“对话即平台（conversation as a platform）” 的战略。此外，苹果 Siri 、亚马逊 Echo 等基于语音对话的产品也非常受欢迎，反映出互联网用户对于聊天和对话这种交互模式的偏好。虽然之前的聊天机器人存在各种问题，但大型语言模型的出现再次让聊天机器人这种交互模式可以重新涌现。用户愈发期待像钢铁侠中“贾维斯”一样的人工智能，无所不能、无所不知。这引发我们对于<code>智能体（Agent）</code>类型应用前景的思考，Auto-GPT、微软 Jarvis 等项目已经出现并受到关注，相信未来会涌现出很多类似的以对话形态让助手完成各种具体工作的项目。</p>\n<h3 id=\"_2-2-llm-的特点\" tabindex=\"-1\"> 2.2 LLM 的特点</h3>\n<p>大语言模型具有多种显著特点，这些特点使它们在自然语言处理和其他领域中引起了广泛的兴趣和研究。以下是大语言模型的一些主要特点：</p>\n<ol>\n<li><strong>巨大的规模：</strong> LLM 通常具有巨大的参数规模，可以达到数十亿甚至数千亿个参数。这使得它们能够捕捉更多的语言知识和复杂的语法结构。</li>\n<li><strong>预训练和微调：</strong> LLM 采用了预训练和微调的学习方法。首先在大规模文本数据上进行预训练（无标签数据），学习通用的语言表示和知识。然后通过微调（有标签数据）适应特定任务，从而在各种 NLP 任务中表现出色。</li>\n<li><strong>上下文感知：</strong> LLM 在处理文本时具有强大的上下文感知能力，能够理解和生成依赖于前文的文本内容。这使得它们在对话、文章生成和情境理解方面表现出色。</li>\n<li><strong>多语言支持：</strong> LLM 可以用于多种语言，不仅限于英语。它们的多语言能力使得跨文化和跨语言的应用变得更加容易。</li>\n<li><strong>多模态支持：</strong> 一些 LLM 已经扩展到支持多模态数据，包括文本、图像和声音。使得它们可以理解和生成不同媒体类型的内容，实现更多样化的应用。</li>\n<li><strong>伦理和风险问题：</strong> 尽管 LLM 具有出色的能力，但它们也引发了伦理和风险问题，包括生成有害内容、隐私问题、认知偏差等。因此，研究和应用 LLM 需要谨慎。</li>\n<li><strong>高计算资源需求：</strong> LLM 参数规模庞大，需要大量的计算资源进行训练和推理。通常需要使用高性能的 GPU 或 TPU 集群来实现。</li>\n</ol>\n<p>大语言模型是一种具有强大语言处理能力的技术，已经在多个领域展示了潜力。它们为自然语言理解和生成任务提供了强大的工具，同时也引发了对其伦理和风险问题的关注。这些特点使 LLM 成为了当今计算机科学和人工智能领域的重要研究和应用方向</p>\n<h2 id=\"三、llm-的应用与影响\" tabindex=\"-1\"> 三、LLM 的应用与影响</h2>\n<p>LLM 已经在许多领域产生了深远的影响。在<strong>自然语言处理</strong>领域，它可以帮助计算机更好地理解和生成文本，包括写文章、回答问题、翻译语言等。在<strong>信息检索</strong>领域，它可以改进搜索引擎，让我们更轻松地找到所需的信息。在<strong>计算机视觉</strong>领域，研究人员还在努力让计算机理解图像和文字，以改善多媒体交互。</p>\n<p>最重要的是，LLM 的出现让人们重新思考了 <strong>通用人工智能（AGI）</strong> 的可能性。AGI 是一种像人类一样思考和学习的人工智能。LLM 被认为是 AGI 的一种早期形式，这引发了对未来人工智能发展的许多思考和计划。</p>\n<p>总之，LLM 是一种令人兴奋的技术，它让计算机更好地理解和使用语言，正在改变着我们与技术互动的方式，同时也引发了对未来人工智能的无限探索。</p>\n<blockquote>\n<p>在下一章我们将介绍 LLM 时期一个重要的技术 RAG。</p>\n</blockquote>\n<p>【<strong>参考内容</strong>】：</p>\n<ol>\n<li><a href=\"https://arxiv.org/abs/2303.18223\" target=\"_blank\" rel=\"noopener noreferrer\">A Survey of Large Language Models</a></li>\n<li><a href=\"https://xueqiu.com/1389978604/248392718\" target=\"_blank\" rel=\"noopener noreferrer\">周枫：当我们谈论大模型时，应该关注哪些新能力？</a></li>\n</ol>\n",
      "image": "https://img.tucang.cc/api/image/show/6c8acb93bd0fc9dd85006746d572df8f",
      "date_published": "2025-01-03T00:00:00.000Z",
      "date_modified": "2025-02-11T00:29:21.000Z",
      "authors": [],
      "tags": [
        "人工智能"
      ]
    },
    {
      "title": "RAG 简介",
      "url": "https://lianghexiang.github.io/space/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/LLM/%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E7%94%9F%E6%88%90RAG.html",
      "id": "https://lianghexiang.github.io/space/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/LLM/%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E7%94%9F%E6%88%90RAG.html",
      "content_html": "<h1 id=\"rag-简介\" tabindex=\"-1\"> RAG 简介</h1>\n<h2 id=\"一、什么是-rag-https-datawhalechina-github-io-llm-universe-c1-2-检索增强生成-rag-简介-id-一、什么是-rag\" tabindex=\"-1\"> [一、什么是 RAG](<a href=\"https://datawhalechina.github.io/llm-universe/#/C1/2.%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E7%94%9F%E6%88%90\" target=\"_blank\" rel=\"noopener noreferrer\">https://datawhalechina.github.io/llm-universe/#/C1/2.检索增强生成</a> RAG 简介?id=一、什么是-rag)</h2>\n<p>大型语言模型（LLM）相较于传统的语言模型具有更强大的能力，然而在某些情况下，它们仍可能无法提供准确的答案。为了解决大型语言模型在生成文本时面临的一系列挑战，提高模型的性能和输出质量，研究人员提出了一种新的模型架构：<strong>检索增强生成（RAG, Retrieval-Augmented Generation）</strong>。该架构巧妙地<strong>整合了从庞大知识库中检索到的相关信息，并以此为基础，指导大型语言模型生成更为精准的答案</strong>，从而显著提升了回答的准确性与深度。</p>\n<p>目前 LLM 面临的主要问题有：</p>\n<ul>\n<li><strong>信息偏差/幻觉：</strong> LLM 有时会产生与客观事实不符的信息，导致用户接收到的信息不准确。RAG 通过检索数据源，辅助模型生成过程，确保输出内容的精确性和可信度，减少信息偏差。</li>\n<li><strong>知识更新滞后性：</strong> LLM 基于静态的数据集训练，这可能导致模型的知识更新滞后，无法及时反映最新的信息动态。RAG 通过实时检索最新数据，保持内容的时效性，确保信息的持续更新和准确性。</li>\n<li><strong>内容不可追溯：</strong> LLM 生成的内容往往缺乏明确的信息来源，影响内容的可信度。RAG 将生成内容与检索到的原始资料建立链接，增强了内容的可追溯性，从而提升了用户对生成内容的信任度。</li>\n<li><strong>领域专业知识能力欠缺：</strong> LLM 在处理特定领域的专业知识时，效果可能不太理想，这可能会影响到其在相关领域的回答质量。RAG 通过检索特定领域的相关文档，为模型提供丰富的上下文信息，从而提升了在专业领域内的问题回答质量和深度。</li>\n<li><strong>推理能力限制：</strong> 面对复杂问题时，LLM 可能缺乏必要的推理能力，这影响了其对问题的理解和回答。RAG 结合检索到的信息和模型的生成能力，通过提供额外的背景知识和数据支持，增强了模型的推理和理解能力。</li>\n<li><strong>应用场景适应性受限：</strong> LLM 需在多样化的应用场景中保持高效和准确，但单一模型可能难以全面适应所有场景。RAG 使得 LLM 能够通过检索对应应用场景数据的方式，灵活适应问答系统、推荐系统等多种应用场景。</li>\n<li><strong>长文本处理能力较弱：</strong> LLM 在理解和生成长篇内容时受限于有限的上下文窗口，且必须按顺序处理内容，输入越长，速度越慢。RAG 通过检索和整合长文本信息，强化了模型对长上下文的理解和生成，有效突破了输入长度的限制，同时降低了调用成本，并提升了整体的处理效率。</li>\n</ul>\n<h2 id=\"二、rag-的工作流程-https-datawhalechina-github-io-llm-universe-c1-2-检索增强生成-rag-简介-id-二、rag-的工作流程\" tabindex=\"-1\"> [二、RAG 的工作流程](<a href=\"https://datawhalechina.github.io/llm-universe/#/C1/2.%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E7%94%9F%E6%88%90\" target=\"_blank\" rel=\"noopener noreferrer\">https://datawhalechina.github.io/llm-universe/#/C1/2.检索增强生成</a> RAG 简介?id=二、rag-的工作流程)</h2>\n<p>RAG 是一个完整的系统，其工作流程可以简单地分为数据处理、检索、增强和生成四个阶段：</p>\n<figure><img src=\"https://github.com/datawhalechina/llm-universe/blob/main/figures/C1-2-RAG.png\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<ol>\n<li>数据处理阶段\n<ol>\n<li>对原始数据进行清洗和处理。</li>\n<li>将处理后的数据转化为检索模型可以使用的格式。</li>\n<li>将处理后的数据存储在对应的数据库中。</li>\n</ol>\n</li>\n<li>检索阶段\n<ol>\n<li>将用户的问题输入到检索系统中，从数据库中检索相关信息。</li>\n</ol>\n</li>\n<li>增强阶段\n<ol>\n<li>对检索到的信息进行处理和增强，以便生成模型可以更好地理解和使用。</li>\n</ol>\n</li>\n<li>生成阶段\n<ol>\n<li>将增强后的信息输入到生成模型中，生成模型根据这些信息生成答案。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"三、rag-vs-finetune-https-datawhalechina-github-io-llm-universe-c1-2-检索增强生成-rag-简介-id-三、rag-vs-finetune\" tabindex=\"-1\"> [三、RAG VS Finetune](<a href=\"https://datawhalechina.github.io/llm-universe/#/C1/2.%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E7%94%9F%E6%88%90\" target=\"_blank\" rel=\"noopener noreferrer\">https://datawhalechina.github.io/llm-universe/#/C1/2.检索增强生成</a> RAG 简介?id=三、rag-vs-finetune)</h2>\n<p>在提升大语言模型效果中，RAG 和 微调（Finetune）是两种主流的方法。</p>\n<p><strong>微调</strong>: 通过在特定数据集上进一步训练大语言模型，来提升模型在特定任务上的表现。</p>\n<p>RAG 和 微调的对比可以参考下表（表格来源[<a href=\"https://arxiv.org/abs/2312.10997\" target=\"_blank\" rel=\"noopener noreferrer\">1</a>][<a href=\"https://baoyu.io/translations/ai-paper/2312.10997-retrieval-augmented-generation-for-large-language-models-a-survey\" target=\"_blank\" rel=\"noopener noreferrer\">2</a>]）</p>\n<table>\n<thead>\n<tr>\n<th>特征比较</th>\n<th>RAG</th>\n<th>微调</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>知识更新</td>\n<td>直接更新检索知识库，无需重新训练。信息更新成本低，适合动态变化的数据。</td>\n<td>通常需要重新训练来保持知识和数据的更新。更新成本高，适合静态数据。</td>\n</tr>\n<tr>\n<td>外部知识</td>\n<td>擅长利用外部资源，特别适合处理文档或其他结构化/非结构化数据库。</td>\n<td>将外部知识学习到 LLM 内部。</td>\n</tr>\n<tr>\n<td>数据处理</td>\n<td>对数据的处理和操作要求极低。</td>\n<td>依赖于构建高质量的数据集，有限的数据集可能无法显著提高性能。</td>\n</tr>\n<tr>\n<td>模型定制</td>\n<td>侧重于信息检索和融合外部知识，但可能无法充分定制模型行为或写作风格。</td>\n<td>可以根据特定风格或术语调整 LLM 行为、写作风格或特定领域知识。</td>\n</tr>\n<tr>\n<td>可解释性</td>\n<td>可以追溯到具体的数据来源，有较好的可解释性和可追踪性。</td>\n<td>黑盒子，可解释性相对较低。</td>\n</tr>\n<tr>\n<td>计算资源</td>\n<td>需要额外的资源来支持检索机制和数据库的维护。</td>\n<td>依赖高质量的训练数据集和微调目标，对计算资源的要求较高。</td>\n</tr>\n<tr>\n<td>推理延迟</td>\n<td>增加了检索步骤的耗时</td>\n<td>单纯 LLM 生成的耗时</td>\n</tr>\n<tr>\n<td>降低幻觉</td>\n<td>通过检索到的真实信息生成回答，降低了产生幻觉的概率。</td>\n<td>模型学习特定领域的数据有助于减少幻觉，但面对未见过的输入时仍可能出现幻觉。</td>\n</tr>\n<tr>\n<td>伦理隐私</td>\n<td>检索和使用外部数据可能引发伦理和隐私方面的问题。</td>\n<td>训练数据中的敏感信息需要妥善处理，以防泄露。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"四、rag-的成功案例-https-datawhalechina-github-io-llm-universe-c1-2-检索增强生成-rag-简介-id-四、rag-的成功案例\" tabindex=\"-1\"> [四、RAG 的成功案例](<a href=\"https://datawhalechina.github.io/llm-universe/#/C1/2.%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E7%94%9F%E6%88%90\" target=\"_blank\" rel=\"noopener noreferrer\">https://datawhalechina.github.io/llm-universe/#/C1/2.检索增强生成</a> RAG 简介?id=四、rag-的成功案例)</h2>\n<p>RAG 已经在多个领域取得了成功，包括问答系统、对话系统、文档摘要、文档生成等。</p>\n<p>我们将在第三部分对 RAG 的应用进行详细介绍。将现有成熟的 RAG 案例进行拆解，和大家一起深入了解 RAG。</p>\n<ol>\n<li><a href=\"https://github.com/logan-zou/Chat_with_Datawhale_langchain\" target=\"_blank\" rel=\"noopener noreferrer\">Datawhale 知识库助手</a> 是结合本课程内容、在由<a href=\"https://github.com/sanbuphy\" target=\"_blank\" rel=\"noopener noreferrer\">散步</a>打造的 <a href=\"https://github.com/sanbuphy/ChatWithDatawhale\" target=\"_blank\" rel=\"noopener noreferrer\">ChatWithDatawhale</a>—— Datawhale 内容学习助手的基础上，将架构调整为初学者容易学习的 LangChain 架构，并参考第二章内容对不同源大模型 API 进行封装的 LLM 应用，能够帮助用户与 DataWhale 现有仓库和学习内容流畅对话，从而帮助用户快速找到想学习的内容和可以贡献的内容。</li>\n<li><a href=\"https://github.com/SocialAI-tianji/Tianji\" target=\"_blank\" rel=\"noopener noreferrer\">天机</a>是 <strong>SocialAI</strong>（来事儿 AI）制作的一款免费使用、非商业用途的人工智能系统。您可以利用它进行涉及传统人情世故的任务，如如何敬酒、如何说好话、如何会来事儿等，以提升您的情商和核心竞争能力。我们坚信，只有人情世故才是未来 AI 的核心技术，只有会来事儿的 AI 才有机会走向 AGI，让我们携手见证通用人工智能的来临。 —— &quot;天机不可泄漏。&quot;</li>\n</ol>\n",
      "image": "https://img.tucang.cc/api/image/show/6c8acb93bd0fc9dd85006746d572df8f",
      "date_published": "2025-01-03T00:00:00.000Z",
      "date_modified": "2025-02-11T00:29:21.000Z",
      "authors": [],
      "tags": [
        "人工智能"
      ]
    },
    {
      "title": "大脑——一切问题的起源",
      "url": "https://lianghexiang.github.io/space/books/%E4%BA%BA%E4%B9%8B%E8%A7%89%E9%86%92/%E4%B8%80%E5%88%87%E9%97%AE%E9%A2%98%E7%9A%84%E8%B5%B7%E6%BA%90.html",
      "id": "https://lianghexiang.github.io/space/books/%E4%BA%BA%E4%B9%8B%E8%A7%89%E9%86%92/%E4%B8%80%E5%88%87%E9%97%AE%E9%A2%98%E7%9A%84%E8%B5%B7%E6%BA%90.html",
      "content_html": "<h1 id=\"大脑——一切问题的起源\" tabindex=\"-1\"> 大脑——一切问题的起源</h1>\n<p>人是特殊的，因为有可以进行自我审视的大脑，有自我意识。但是我们大多数人都不了解自己的大脑，所以才会对自身产生的问题感到困惑。现在，我们从了解大脑开始，重新认识“自己”</p>\n\n<nav><ul><li><router-link to=\"#第一节-大脑-重新认识你自己\"><i>Content not supported</i> 第一节　大脑：重新认识你自己</router-link><ul><li><router-link to=\"#_1-三重大脑\">1.三重大脑</router-link></li></ul></li></ul></nav>\n<h2 id=\"第一节-大脑-重新认识你自己\" tabindex=\"-1\"> <i>Content not supported</i> 第一节　大脑：重新认识你自己</h2>\n<h3 id=\"_1-三重大脑\" tabindex=\"-1\"> 1.三重大脑</h3>\n<div>\n<p>大脑的进化</p>\n<p>人类聪明的大脑并不是突然出现，而是经过漫长的演化。从远古海洋的“复制子”，进化成为单细胞，接着又演化为动物、植物和微生物等，最终这些生物爬上陆地，开始了爬行动物的时代。后来，开始出现哺乳动物，为了适应环境， 进化出了&quot;情绪脑&quot;，而人类因为进化出了无与伦比的大脑&quot;新皮层&quot;，所以在哺乳类动物中脱颖而出，成为&quot;万物之灵&quot;，这一块新的区域被称为&quot;理智脑&quot;。</p>\n</div>\n<p><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepress/2024-02-05-POggHv.png\" alt=\"\" loading=\"lazy\"><br>\n<img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepress/2024-02-05-De6pnz.png\" alt=\"33\" loading=\"lazy\"></p>\n<h4 id=\"本能脑\" tabindex=\"-1\"> 1️⃣本能脑</h4>\n<p>爬行动物时代进化出的脑结构。本能脑的结构很简单，只有一个原始的反射模块，可以让爬行动物对环境快速做出本能反应。<br>\n爬行动物的特点：</p>\n<ul>\n<li>没有情感也没有理智</li>\n<li>大脑结构简单</li>\n<li>体温无法恒定<br>\n因为<strong>本能脑</strong>是最原始的脑结构，所以本能脑也被称为原始脑、基础脑、鳄鱼脑、蜥蜴脑，或者干脆叫爬行脑。</li>\n</ul>\n<h4 id=\"情绪脑\" tabindex=\"-1\"> 2️⃣情绪脑</h4>\n<div>\n<p>情绪脑</p>\n<p>2亿年前的哺乳动物时代进化出的脑结构.<br>\n哺乳动物为了适应环境，不仅能让身体温度保持恒定，还进化出了<strong>情绪脑</strong>，</p>\n</div>\n<h4 id=\"理智脑\" tabindex=\"-1\"> 3️⃣理智脑</h4>\n",
      "image": "https://img.tucang.cc/api/image/show/162dc86c7925e40d3e32b8b1cc036876",
      "date_published": "2024-01-31T00:00:00.000Z",
      "date_modified": "2024-11-29T07:02:46.000Z",
      "authors": [
        {
          "name": "梁贺祥"
        }
      ],
      "tags": [
        "读书笔记"
      ]
    },
    {
      "title": "2023初雪",
      "url": "https://lianghexiang.github.io/space/diary/%E5%B0%8F%E8%AE%B0/%E4%B8%8B%E9%9B%AA%E5%95%A6.html",
      "id": "https://lianghexiang.github.io/space/diary/%E5%B0%8F%E8%AE%B0/%E4%B8%8B%E9%9B%AA%E5%95%A6.html",
      "content_html": "<h1 id=\"_2023初雪\" tabindex=\"-1\"> 2023初雪</h1>\n<figure><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepress/微信图片_20231211101841.jpg\" alt=\"好白的雪\" tabindex=\"0\" loading=\"lazy\"><figcaption>好白的雪</figcaption></figure>\n<figure><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepress/微信图片_20231211102037.jpg\" alt=\"白雪皑皑\" tabindex=\"0\" loading=\"lazy\"><figcaption>白雪皑皑</figcaption></figure>\n",
      "image": "https://img.tucang.cc/api/image/show/da3546c26f3726a1f7a63e96921b30ff",
      "date_published": "2023-12-11T00:00:00.000Z",
      "date_modified": "2024-11-29T07:02:46.000Z",
      "authors": [],
      "tags": [
        "画册"
      ]
    },
    {
      "title": "网站推荐",
      "url": "https://lianghexiang.github.io/space/diary/%E5%B0%8F%E8%AE%B0/%E5%A5%BD%E7%94%A8%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F.html",
      "id": "https://lianghexiang.github.io/space/diary/%E5%B0%8F%E8%AE%B0/%E5%A5%BD%E7%94%A8%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F.html",
      "content_html": "<h1 id=\"网站推荐\" tabindex=\"-1\"> 网站推荐</h1>\n<h3 id=\"_1-http-sparkbyexamples-com\" tabindex=\"-1\"> <i>Content not supported</i> 1. <a href=\"http://sparkbyexamples.com/\" target=\"_blank\" rel=\"noopener noreferrer\">http://sparkbyexamples.com/</a></h3>\n<div>\n<p>收藏理由</p>\n<p>是一个学习编程技术的网站，我主要是用来学习PySpark，因为这个网站的文档相比于官方文档来说，它的目录结构就比较一目了然，整体比较清晰；<br>\n而且，关于PySpark的每个模块，每个方法，它都用比较好理解的语言描述。然后，还会有示例代码来以更加直观的方式让读者明白相关模块如何使用</p>\n</div>\n<i>Content not supported</i>\n<h3 id=\"_2-https-www-exception-site\" tabindex=\"-1\"> <i>Content not supported</i> 2. <a href=\"https://www.exception.site\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.exception.site</a></h3>\n<div>\n<p>破解Pycharm</p>\n<p>常用IDE破解工具网站，包括了jetbrain全家桶系列，还有一些别的工具的破解方法，比如Xshell、Typora这些耳熟能详的工具,<br>\n而且教程详细易懂，附带破解工具下载，还包含了常见问题的解决办法，总之是一个不可多得的值得收藏的破解网站。非常好用❥</p>\n</div>\n<i>Content not supported</i>\n",
      "image": "https://img.tucang.cc/api/image/show/97c5d0c0a9f9c7aae374b30ce9f16e6d",
      "date_published": "2023-12-11T00:00:00.000Z",
      "date_modified": "2024-11-29T07:02:46.000Z",
      "authors": [],
      "tags": [
        "网址收藏"
      ]
    },
    {
      "title": "单例模式",
      "url": "https://lianghexiang.github.io/space/posts/design_pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html",
      "id": "https://lianghexiang.github.io/space/posts/design_pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html",
      "content_html": "<h1 id=\"单例模式\" tabindex=\"-1\"> 单例模式</h1>\n<div>\n<p>单例模式</p>\n<p>单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p>\n</div>\n<h2 id=\"单例模式结构\" tabindex=\"-1\"> 单例模式结构</h2>\n<figure><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepress/2024-04-26-bWP3E8.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2 id=\"单例模式的python实现\" tabindex=\"-1\"> 单例模式的Python实现</h2>\n<h3 id=\"_1-普通单例模式\" tabindex=\"-1\"> 1. 普通单例模式</h3>\n<blockquote>\n<p>_ <em>new</em> _方法可以在实例化类的时候通过hasattr方法返回同一个实例</p>\n</blockquote>\n<p>:sad:</p>\n<div data-ext=\"py\"><pre><code><span>class</span> <span>ExerciseSinglePattern</span><span>:</span>\n    <span>def</span> <span>__new__</span><span>(</span>cls<span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>\n        <span>if</span> <span>not</span> <span>hasattr</span><span>(</span>cls<span>,</span> <span>'_instance'</span><span>)</span><span>:</span>\n            cls<span>.</span>_instance <span>=</span> <span>super</span><span>(</span><span>)</span><span>.</span>__new__<span>(</span>cls<span>)</span>\n        <span>return</span> cls<span>.</span>_instance\n\n    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> a<span>,</span> b<span>)</span><span>:</span>\n        <span>print</span><span>(</span><span>'__init__'</span><span>)</span>\n        self<span>.</span>a <span>=</span> a\n        self<span>.</span>b <span>=</span> b\n<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>\n    sp <span>=</span> ExerciseSinglePattern<span>(</span><span>'a'</span><span>,</span> <span>'b'</span><span>)</span>\n    sp2 <span>=</span> ExerciseSinglePattern<span>(</span><span>'c'</span><span>,</span> <span>'d'</span><span>)</span>\n    <span>print</span><span>(</span>sp<span>)</span>\n    <span>print</span><span>(</span>sp2<span>)</span>\n    <span># &lt;__main__.ExerciseSinglePattern object at 0x00000243AF6E4F70></span>\n\t<span># &lt;__main__.ExerciseSinglePattern object at 0x00000243AF6E4F70></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"_2-使用装饰器实现单例模式\" tabindex=\"-1\"> 2. 使用装饰器实现单例模式</h3>\n<h4 id=\"_2-1-装饰器-decorators\" tabindex=\"-1\"> 2.1 装饰器（Decorators）</h4>\n<blockquote>\n<p>装饰器是Python中很重要的内容，属于Python的进阶知识；装饰器的本质可以理解为一个高阶函数，因为它返回的是一个函数对象。装饰器可以在不修改被装饰代码的情况下对代码增加额外的功能，这种动态增加功能的方式，我们称之为“装饰器”.</p>\n</blockquote>\n<p>1️⃣<strong>普通装饰器：</strong></p>\n<p>一般来说，装饰器的基本代码格式为两层嵌套函数，如下所示：</p>\n<div data-ext=\"py\"><pre><code>\n<span># 装饰器</span>\n<span>def</span> <span>decorator</span><span>(</span>func<span>:</span>被装饰函数<span>)</span><span>:</span>\n    <span>def</span> <span>wrapper</span><span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span><span># *args和**kwargs主要是被装饰函数所需的参数</span>\n        <span># 函数执行前的操作</span>\n        <span>print</span><span>(</span><span>\"Start:\"</span><span>)</span>\n        func<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>\n        <span># 函数执行后的操作</span>\n        <span>print</span><span>(</span><span>\"End\"</span><span>)</span>\n    <span>return</span> wrapper\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>以上就是一个简单的装饰器，如果要使用装饰器，则使用Python中的语法糖<code>@</code></p>\n<div data-ext=\"py\"><pre><code><span># 基本函数</span>\n<span>def</span> <span>test</span><span>(</span>text<span>)</span><span>:</span>\n    <span>print</span><span>(</span>text<span>)</span>\n    \n<span># 使用装饰器后的函数</span>\n<span>@decorator</span>\n<span>def</span> <span>test</span><span>(</span>text<span>)</span><span>:</span>\n    <span>print</span><span>(</span>text<span>)</span>\n<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>\n    test<span>(</span><span>'装饰器'</span><span>)</span>\n  \t<span>\"\"\"\n  \tStart:\n\t装饰器\n\tEnd\n  \t\"\"\"</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>2️⃣<strong>带参数的装饰器:</strong></p>\n<blockquote>\n<p>如果装饰器本身需要传递参数，则需要构建一个可以返回装饰器的高阶函数。</p>\n</blockquote>\n<div data-ext=\"py\"><pre><code><span># 带有参数的装饰器</span>\n<span>def</span> <span>logger_decorator</span><span>(</span>log_info<span>)</span><span>:</span>\n    <span># 装饰器</span>\n    <span>def</span> <span>decorator</span><span>(</span>func<span>)</span><span>:</span>\n        <span># 内层函数</span>\n        <span>def</span> <span>wrapper</span><span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>\n            <span>print</span><span>(</span><span><span>f\"</span><span><span>{</span>func<span>.</span>__name__<span>}</span></span><span>:</span><span><span>{</span>log_info<span>}</span></span><span>\"</span></span><span>)</span>\n            func<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>\n        <span>return</span> wrapper\n    <span>return</span> decorator\n\n<span># 带有参数的装饰器使用方法如下</span>\n<span>@logger_decorator</span><span>(</span><span>\"Start...\"</span><span>,</span> <span>\"...End\"</span><span>)</span>\n<span>def</span> <span>test2</span><span>(</span><span>)</span><span>:</span>\n    <span>print</span><span>(</span><span>\"正在插入数据\"</span><span>)</span>\n    time<span>.</span>sleep<span>(</span><span>5</span><span>)</span>\n    \n<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>\n    <span># test('装饰器')</span>\n    test2<span>(</span><span>)</span>\n    \n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><figure><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepress/image-20231230132509562.png\" alt=\"image-20231230132509562\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20231230132509562</figcaption></figure>\n<p>在我们执行被装饰器装饰的函数时，我们使用函数的方式和普通函数无异，也就是说如果我们想要对<code>test2()</code>函数增加打印执行时间的功能，我们只需要添加一个装饰器，由于函数调用的方式并没有发生变化，所以就无需更改任何原代码就可完成对代码额外功能的增加</p>\n<p>我们来剖析一下上面调用<code>test()</code>函数时，程序的执行流程</p>\n<div data-ext=\"py\"><pre><code><span>#我们在调用test2()函数时，程序的执行顺序如下</span>\nlogger_decorator<span>(</span>arg1<span>,</span>arg2<span>)</span><span>(</span>test2<span>)</span><span>(</span><span>*</span>args<span>,</span><span>**</span>kwargs<span>)</span>\n<span># 1. 首先，执行的是logger_decorator</span>\nlogger_decorator<span>(</span>arg1<span>,</span>arg2<span>)</span>\n<span># 2. 由上面的函数可知，logger_decorator函数返回的是decorator</span>\ndecorator <span>=</span> logger_decorator<span>(</span>arg1<span>,</span>arg2<span>)</span>\n<span># 3. decorator接受一个参数func，这个参数就是被装饰函数的引用，接下来</span>\nwrapper <span>=</span> decorator<span>(</span>test2<span>)</span>\n<span># 4. 其实，在执行test2时，实际上执行的是wrapper</span>\nwrapper<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>\n<span># 以上就是通过装饰器装饰后的函数的整体流程</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>3️⃣:<strong>通过签名调用的函数</strong></p>\n<blockquote>\n<p>上面我们说过，使用装饰器装饰过的函数，使用方法和被装饰前无异，但是有另外一种情况：我们依赖某个函数的签名，即func.<strong>name</strong>，此时我们如果装饰func的话，func.__name__就会发生改变，因为实际上func已经变成了wrapper，所以依赖函数签名的程序就会报错。针对这种情况，我们使用python内置的方法即可解决：functools.wraps函数</p>\n</blockquote>\n<p>如果我们不使用functools.wraps:</p>\n<div data-ext=\"py\"><pre><code><span>def</span> <span>wraps_decorator</span><span>(</span>func<span>)</span><span>:</span>\n    <span>def</span> <span>wrapper</span><span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>\n        <span>print</span><span>(</span><span>\"Do Something......\"</span><span>)</span>\n        <span>return</span> func<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>\n    <span>return</span> wrapper\n\n<span>@wraps_decorator</span>\n<span>def</span> <span>wraps_test</span><span>(</span>text<span>)</span><span>:</span>\n    <span>print</span><span>(</span>text<span>)</span>\n    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>\n<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>\n    <span># 我们如果不使用functools.wraps</span>\n    func_name <span>=</span> wraps_test<span>.</span>__name__\n    <span>print</span><span>(</span><span><span>f\"wraps_test函数名称：</span><span><span>{</span>func_name<span>}</span></span><span>\"</span></span><span>)</span>\n    \n    <span>\"\"\"\n    wraps_test函数名称：wrapper\n    \"\"\"</span>\n    \n    <span># 我们可以看到，wraps_test签名变成了wrapper</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>使用functools.wraps</strong>：</p>\n<div data-ext=\"py\"><pre><code><span># 使用方式很简单，通过装饰器的写法装饰内层函数即可</span>\n<span>import</span> functools\n\n\n<span>def</span> <span>wraps_decorator</span><span>(</span>func<span>)</span><span>:</span>\n    <span>@functools<span>.</span>wraps</span><span>(</span>func<span>)</span>\n    <span>def</span> <span>wrapper</span><span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>\n        <span>print</span><span>(</span><span>\"Do Something......\"</span><span>)</span>\n        <span>return</span> func<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>\n    <span>return</span> wrapper\n\n<span>@wraps_decorator</span>\n<span>def</span> <span>wraps_test</span><span>(</span>text<span>)</span><span>:</span>\n    <span>print</span><span>(</span>text<span>)</span>\n    time<span>.</span>sleep<span>(</span><span>2</span><span>)</span>\n<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>\n\n    <span># 使用functools.wraps</span>\n    func_name <span>=</span> wraps_test<span>.</span>__name__\n    <span>print</span><span>(</span><span><span>f\"wraps_test函数名称：</span><span><span>{</span>func_name<span>}</span></span><span>\"</span></span><span>)</span>\n    <span>\"\"\"\n    wraps_test函数名称：wraps_test\n    \"\"\"</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id=\"_2-2-使用装饰器实现单例模式\" tabindex=\"-1\"> 2.2 使用装饰器实现单例模式</h4>\n<blockquote>\n<p>上面讲解完了装饰器，我们可以了解到装饰器可以拓展函数的功能，接下来我们就使用一点小技巧通过装饰器对类进行装饰，从而实现单例的需求</p>\n</blockquote>\n<div data-ext=\"py\"><pre><code><span># 首先，我们要实现单例模式，和普通单例模式类似，</span>\n<span># 我们要知道某个类A是否已经创建实例，如果已经创建实例则返回，所以我们可以通过字典来实现</span>\n<span># 装饰器单例模式</span>\n<span>def</span> <span>singleton_decorator</span><span>(</span>cls<span>)</span><span>:</span>\n    <span># 创建一个存储类实例的字段</span>\n    _instances <span>=</span> <span>{</span><span>}</span>\n    <span>def</span> <span>wrapper</span><span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>\n        <span>if</span> cls <span>not</span> <span>in</span> _instances<span>:</span>\n            _instances<span>[</span>cls<span>]</span> <span>=</span> cls<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>\n        <span>return</span> _instances<span>[</span>cls<span>]</span>\n    <span>return</span> wrapper\n\n\n<span>@singleton_decorator</span>\n<span>class</span> <span>DecoratorSingleton</span><span>:</span>\n    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>=</span><span>None</span><span>)</span><span>:</span>\n        self<span>.</span>name <span>=</span> name\n\n<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>\n    dt_singleton <span>=</span> DecoratorSingleton<span>(</span><span>\"Decorator Singleton\"</span><span>)</span>\n    <span>print</span><span>(</span>dt_singleton<span>)</span>\n    dt_singleton2 <span>=</span> DecoratorSingleton<span>(</span><span>\"Decorator Singleton2\"</span><span>)</span>\n    <span>print</span><span>(</span>dt_singleton2<span>)</span>\n    <span>\"\"\"\n    &lt;__main__.DecoratorSingleton object at 0x000002AFB008FBB0>\n\t&lt;__main__.DecoratorSingleton object at 0x000002AFB008FBB0>\n    \"\"\"</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"_3-单态模式-单例模式的一种\" tabindex=\"-1\"> 3. 单态模式(单例模式的一种)</h3>\n<blockquote>\n<p>单例模式是指，一个类只有一个对象，然而，单态模式更关心的是状态和行为，即所有对象共享相同的状态，所以基于这类思想设计的类也叫做Monostate(单态)模式</p>\n</blockquote>\n<p>我们知道，在Python独享中，__dict___存储了一个对象所有的变量，所以如果我们在实例化对象时所有对象的<code>__dict__</code>指向的是同一个引用，那么当某个实例a更改了属性，那么其他实例也能同步，达到所有对象共享相同状态的目的。</p>\n<div data-ext=\"py\"><pre><code><span>\"\"\"\n单态模式的实现\n\"\"\"</span>\n<span>class</span> <span>Borg</span><span>:</span>\n    <span># 类属性</span>\n    __shared_state <span>=</span> <span>{</span><span>'name'</span><span>:</span> <span>None</span><span>}</span>\n    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>\n        self<span>.</span>__dict__ <span>=</span> self<span>.</span>__shared_state\n\n\n<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>\n    a <span>=</span> Borg<span>(</span><span>)</span>\n    b <span>=</span> Borg<span>(</span><span>)</span>\n    <span># 此时，如果对a设置属性age，则b也会被赋予属性age</span>\n    a<span>.</span>age <span>=</span> <span>20</span>\n\n    <span>print</span><span>(</span>a<span>.</span>age<span>)</span>\n    <span>print</span><span>(</span>b<span>.</span>age<span>)</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>单态模式还可以通过<code>__new__</code>方法实现:</p>\n<div data-ext=\"py\"><pre><code><span>class</span> <span>NewBorg</span><span>:</span>\n    __shared_state <span>=</span> <span>{</span><span>}</span>\n    <span># TODO 1 重新new方法</span>\n    <span>def</span> <span>__new__</span><span>(</span>cls<span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>\n        <span># TODO 2 生成shili</span>\n        borg_obj <span>=</span> <span>super</span><span>(</span><span>)</span><span>.</span>__new__<span>(</span>cls<span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>\n        <span># TODO 3 将实例的__dict__指向类属性__shared_state</span>\n        borg_obj<span>.</span>__dict__ <span>=</span> cls<span>.</span>__shared_state\n        <span>return</span> borg_obj\n    \n    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>\n        self<span>.</span>name <span>=</span> <span>'Borg1'</span>\n        \n        \n<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>\n    a <span>=</span> Borg<span>(</span><span>)</span>\n    b <span>=</span> Borg<span>(</span><span>)</span>\n    <span># 此时，如果对a设置属性age，则b也会被赋予属性age</span>\n    a<span>.</span>age <span>=</span> <span>20</span>\n\n    <span>print</span><span>(</span>a<span>.</span>age<span>)</span>\n    <span>print</span><span>(</span>b<span>.</span>age<span>)</span>\n\n\n    new_borg <span>=</span> NewBorg<span>(</span><span>)</span>\n    new_borg_2 <span>=</span> NewBorg<span>(</span><span>)</span>\n    <span>print</span><span>(</span><span><span>f\"更新name属性前：</span><span><span>{</span>new_borg<span>.</span>name<span>}</span></span><span>\"</span></span><span>)</span> <span># 更新name属性前：Borg1</span>\n    <span># 更改name属性</span>\n    new_borg_2<span>.</span>name <span>=</span> <span>\"Borg2\"</span>\n    <span>print</span><span>(</span><span><span>f\"更新name属性后：</span><span><span>{</span>new_borg<span>.</span>name<span>}</span></span><span>\"</span></span><span>)</span> <span># 更新name属性后：Borg2</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"_4-单例和元类\" tabindex=\"-1\"> 4. 单例和元类</h3>\n<h4 id=\"_4-1-元类\" tabindex=\"-1\"> 4.1 元类</h4>\n<blockquote>\n<p>我们先来简单的了解一下元类，元类的意思是一个类的类，这意味着类是元类的实例。使用元类，我们有机会从预定义的Python类中创建自己想要的类型的类。下面我们来通过实例来体会一下什么是元类。</p>\n</blockquote>\n<div data-ext=\"py\"><pre><code>a <span>=</span> <span>10</span>\n<span>print</span><span>(</span><span>type</span><span>(</span>a<span>)</span><span>)</span>  <span># &lt;class 'int'></span>\n<span>print</span><span>(</span><span>type</span><span>(</span><span>int</span><span>)</span><span>)</span>  <span># &lt;class 'type'></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>类的定义有它的元类决定，当我们创建一个类A时，Python则是相当于实例化了type类: <code>A=type(name,bases,dict)</code>。</p>\n<ul>\n<li><strong>name</strong> : 这是类的名称</li>\n<li><strong>bases</strong>: 这是基类</li>\n<li><strong>dict</strong>：这是类的属性变量</li>\n</ul>\n<h4 id=\"_4-2-元类实现单例模式\" tabindex=\"-1\"> 4.2 元类实现单例模式</h4>\n<p>接下来我们看一下简单的元类示例：</p>\n<div data-ext=\"py\"><pre><code><span>class</span> <span>MyInt</span><span>(</span><span>type</span><span>)</span><span>:</span>\n    <span># __call__方法在类以函数方式调用的时候被触发</span>\n    <span>def</span> <span>__call__</span><span>(</span>cls<span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>\n        <span>print</span><span>(</span><span>\"*** 自定义元类 Int类型 ***\"</span><span>,</span> args<span>)</span>\n        <span>print</span><span>(</span><span>\"在这里可以自定义你自己的类的行为.....\"</span><span>)</span>\n        <span>return</span> <span>type</span><span>.</span>__call__<span>(</span>cls<span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>\n\n<span># 使用上面自定义的元类来创建int类型</span>\n<span>class</span> <span>int</span><span>(</span>metaclass<span>=</span>MyInt<span>)</span><span>:</span>\n    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> x<span>,</span> y<span>)</span><span>:</span>\n        self<span>.</span>x <span>=</span> x\n        self<span>.</span>y <span>=</span> y\n        \n<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>\n    my_int <span>=</span> <span>int</span><span>(</span><span>10</span><span>,</span> <span>20</span><span>)</span>\n<span># 以下是上面代码的输出结果</span>\n<span>**</span><span>*</span> 自定义元类 Int类型 <span>**</span><span>*</span> <span>(</span><span>10</span><span>,</span> <span>20</span><span>)</span>\n在这里可以自定义你自己的类的行为<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>将需要创建对象时，Python将调用<code>__call__</code>方法，所以上面在创建my_int对象时<code>MyInt</code>就会调用我们自定义的<code>__call__</code>方法。</p>\n<p>由于元类对对象的实例化有更多的控制权，所以它可以用来创建单例。</p>\n<p>下面我们基于元类来实现单例：</p>\n<div data-ext=\"py\"><pre><code><span># 使用元类创建单例</span>\n<span>class</span> <span>MetaSingleton</span><span>(</span><span>type</span><span>)</span><span>:</span>\n    _instances <span>=</span> <span>{</span><span>}</span>\n    <span># 覆盖type的__call__方法</span>\n\n    <span>def</span> <span>__call__</span><span>(</span>cls<span>,</span> <span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span><span>:</span>\n        <span>if</span> cls <span>not</span> <span>in</span> cls<span>.</span>_instances<span>:</span>\n            cls<span>.</span>_instances<span>[</span>cls<span>]</span> <span>=</span> <span>super</span><span>(</span>MetaSingleton<span>,</span> cls<span>)</span><span>.</span>__call__<span>(</span><span>*</span>args<span>,</span> <span>**</span>kwargs<span>)</span>\n        <span>return</span> cls<span>.</span>_instances<span>[</span>cls<span>]</span>\n\n\n<span>class</span> <span>Logger</span><span>(</span>metaclass<span>=</span>MetaSingleton<span>)</span><span>:</span>\n    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> level<span>)</span><span>:</span>\n        self<span>.</span>level <span>=</span> level\n\n\n<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>\n    my_int <span>=</span> <span>int</span><span>(</span><span>10</span><span>,</span> <span>20</span><span>)</span>\n\n    logger_1 <span>=</span> Logger<span>(</span><span>'info'</span><span>)</span>\n    logger_2 <span>=</span> Logger<span>(</span><span>'error'</span><span>)</span>\n    <span>print</span><span>(</span>logger_1<span>)</span>\n    <span>print</span><span>(</span>logger_2<span>)</span>\n    \n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>以下是上面代码的输出：</p>\n<div data-ext=\"py\"><pre><code><span>>></span><span>>></span><span>>></span>\n<span>&lt;</span>__main__<span>.</span>Logger <span>object</span> at <span>0x00000204A6EFFCA0</span><span>></span>\n<span>&lt;</span>__main__<span>.</span>Logger <span>object</span> at <span>0x00000204A6EFFCA0</span><span>></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>在上面的代码中，我们通过继承<code>type</code>类，然后重写<code>__call__</code>的方法，每次创建实例的时候都去<code>_instances</code>中去寻找已经创建的实例，然后返回。</p>\n<h3 id=\"_5-单例模式的缺点\" tabindex=\"-1\"> 5. 单例模式的缺点</h3>\n<p>单例具有全局访问权限，因此会存在以下问题。</p>\n<p>全局变量可能在某处代码被修改，但是开发人员并未注意到，如果有其它地方也使用，可能会发生异常。</p>\n<p>由于单例只能创建一次，所以会有多个引用指向同一个对象。</p>\n<p>所有依赖全局变量的类都会由于一个类的改变而紧密耦合为全局数据，从而可能无意中影响另一个类。</p>\n",
      "image": "https://img.tucang.cc/api/image/show/6c8acb93bd0fc9dd85006746d572df8f",
      "date_published": "2024-01-03T00:00:00.000Z",
      "date_modified": "2024-11-29T07:02:46.000Z",
      "authors": [],
      "tags": [
        "python"
      ]
    },
    {
      "title": "工厂模式",
      "url": "https://lianghexiang.github.io/space/posts/design_pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html",
      "id": "https://lianghexiang.github.io/space/posts/design_pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html",
      "content_html": "<h1 id=\"工厂模式\" tabindex=\"-1\"> 工厂模式</h1>\n<h3 id=\"_1-前言\" tabindex=\"-1\"> 1. 前言</h3>\n<p>在本文章中，主要包含以下几个方面的主题：</p>\n<ol>\n<li>了解简单工厂设计模式；</li>\n<li>讨论工厂方法和抽象工厂方法及其差异；</li>\n<li>利用Python代码实现真实场景；</li>\n<li>讨论模式的优缺点并进行相应的比较。</li>\n</ol>\n<h3 id=\"_2-了解工厂模式\" tabindex=\"-1\"> 2. 了解工厂模式</h3>\n<p>在面向对象编程中，术语“工厂”表示一个负责创建其他类型对象的类。通常情况下，作为一个工厂的类有一个对象以及与它关联的多个方法。客户端使用某些参数调用此方法，之后，工厂会据此创建所需类型的对象，然后将它们返回给客户端。</p>\n<p>❓其实客户端可以直接创建对象，那么为什么需要工厂？</p>\n<p>1️⃣<strong>松耦合</strong>：即对象的创建可以独立于类的实现。</p>\n",
      "image": "https://img.tucang.cc/api/image/show/6c8acb93bd0fc9dd85006746d572df8f",
      "date_published": "2024-01-03T00:00:00.000Z",
      "date_modified": "2024-11-29T07:02:46.000Z",
      "authors": [],
      "tags": [
        "python"
      ]
    },
    {
      "title": "门面模式",
      "url": "https://lianghexiang.github.io/space/posts/design_pattern/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F.html",
      "id": "https://lianghexiang.github.io/space/posts/design_pattern/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F.html",
      "content_html": "<h1 id=\"门面模式\" tabindex=\"-1\"> 门面模式</h1>\n<p>本章涉及内容：</p>\n<ol>\n<li>\n<p>结构型设计模式概要；</p>\n</li>\n<li>\n<p>利用UML图理解门面设计模式；</p>\n</li>\n<li>\n<p>提供了Python v3.5实现代码的真实用例；</p>\n</li>\n<li>\n<p>门面模式与最少知识原则。</p>\n</li>\n</ol>\n<h3 id=\"_1-什么是结构性设计模式\" tabindex=\"-1\"> 1. 什么是结构性设计模式</h3>\n",
      "image": "https://img.tucang.cc/api/image/show/6c8acb93bd0fc9dd85006746d572df8f",
      "date_published": "2024-01-03T00:00:00.000Z",
      "date_modified": "2024-11-29T07:02:46.000Z",
      "authors": [],
      "tags": [
        "python"
      ]
    },
    {
      "title": "向量数据库",
      "url": "https://lianghexiang.github.io/space/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/LLM/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93.html",
      "id": "https://lianghexiang.github.io/space/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/LLM/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93.html",
      "content_html": "<h1 id=\"向量数据库\" tabindex=\"-1\"> 向量数据库</h1>\n",
      "image": "https://img.tucang.cc/api/image/show/6c8acb93bd0fc9dd85006746d572df8f",
      "date_published": "2024-11-28T00:00:00.000Z",
      "date_modified": "2024-11-29T07:02:46.000Z",
      "authors": [],
      "tags": [
        "人工智能"
      ]
    },
    {
      "title": "DBUtils版本问题",
      "url": "https://lianghexiang.github.io/space/posts/python/DBUtils%E5%AF%BC%E5%85%A5.html",
      "id": "https://lianghexiang.github.io/space/posts/python/DBUtils%E5%AF%BC%E5%85%A5.html",
      "content_html": "<h1 id=\"dbutils版本问题\" tabindex=\"-1\"> DBUtils版本问题</h1>\n<h3 id=\"前言\" tabindex=\"-1\"> 前言</h3>\n<figure><img src=\"https://img2023.cnblogs.com/blog/2432585/202307/2432585-20230719090938564-1692406477.png\" alt=\"image\" tabindex=\"0\" loading=\"lazy\"><figcaption>image</figcaption></figure>\n<p>事情的起因是，原本在pycharm上开发的代码，因为要使用到线程池，所以就按安装了DBUtils，在windows上运行代码倒没什么问题，后因代码运行时需要占用的内存过多，所以代码要转移到Linux服务器上，问题由之而来，运行代码时总会会报出找不到DBUtils库的错误，经过几番反复确认，python环境已经安装了DBUtils，而且安装的其他三方库皆无问题，所以便是用了万能的百度，终于是解决了问题</p>\n<h3 id=\"如何解决\" tabindex=\"-1\"> 如何解决</h3>\n<p>更改导入模块的写法即可</p>\n<div data-ext=\"py\"><pre><code><span>from</span> dbutils<span>.</span>pooled_db <span>import</span> PooledDB\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>网上有教程说是版本 &lt;=1.3的DBUtils.PooledDB的方式导入是没问题的，但是我把版本降低到1.3还是出错，最终还是选择了&gt;=2.0的版本，使用<code>from dbutils.pooled_db import PooledDB</code>的方式导入，最终完美解决问题。</p>\n",
      "image": "https://img.tucang.cc/api/image/show/da3546c26f3726a1f7a63e96921b30ff",
      "date_published": "2023-07-28T00:00:00.000Z",
      "date_modified": "2024-11-29T07:02:46.000Z",
      "authors": [],
      "tags": [
        "技术"
      ]
    },
    {
      "title": "PySpark之parallelize()",
      "url": "https://lianghexiang.github.io/space/posts/pyspark/PySpark%E4%B9%8BParallelize.html",
      "id": "https://lianghexiang.github.io/space/posts/pyspark/PySpark%E4%B9%8BParallelize.html",
      "content_html": "<h1 id=\"pyspark之parallelize\" tabindex=\"-1\"> PySpark之parallelize()</h1>\n",
      "image": "https://img.tucang.cc/api/image/show/97c5d0c0a9f9c7aae374b30ce9f16e6d",
      "date_published": "2024-04-19T00:00:00.000Z",
      "date_modified": "2024-06-24T01:38:14.000Z",
      "authors": [],
      "tags": [
        "技术",
        "PySpark"
      ]
    },
    {
      "title": "PySpark初学者教程",
      "url": "https://lianghexiang.github.io/space/posts/pyspark/PySpark%E5%88%9D%E5%AD%A6%E8%80%85%E6%95%99%E7%A8%8B.html",
      "id": "https://lianghexiang.github.io/space/posts/pyspark/PySpark%E5%88%9D%E5%AD%A6%E8%80%85%E6%95%99%E7%A8%8B.html",
      "content_html": "<h1 id=\"pyspark初学者教程\" tabindex=\"-1\"> PySpark初学者教程</h1>\n<div>\n<p>Spark版本信息</p>\n<p>本教程以下所有内容都是基于Spark3.5版本</p>\n</div>\n<h2 id=\"_1-pyspark简介\" tabindex=\"-1\"> 1. PySpark简介</h2>\n<blockquote>\n<p>PySpark 教程 – PySpark 是一个用 Python 编写的 Apache Spark 库，用于使用 Apache Spark 功能运行 Python 应用程序。使用 PySpark 我们可以在分布式集群（多个节点）上并行运行应用程序。<br>\n换句话说，PySpark 是一个 Python API，是一个用于大规模强大的分布式数据处理和机器学习应用程序的分析处理引擎。</p>\n</blockquote>\n<figure><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepress/img.png\" alt=\"img.png\" tabindex=\"0\" loading=\"lazy\"><figcaption>img.png</figcaption></figure>\n<h3 id=\"_1-1-pyspark特点\" tabindex=\"-1\"> 1.1 PySpark特点</h3>\n<ol>\n<li>内存计算</li>\n<li>使用并行化进行分布式处理</li>\n<li>可与许多集群管理器（Spark、Yarn、Mesos 等）一起使用</li>\n<li>容错</li>\n<li>不可变的</li>\n<li>惰性评估</li>\n<li>缓存和持久化</li>\n<li>使用 DataFrame 时的内置优化</li>\n<li>支持ANSI SQL</li>\n</ol>\n<h3 id=\"_1-2-pyspark优点\" tabindex=\"-1\"> 1.2 Pyspark优点</h3>\n<ol>\n<li>PySpark 是一种通用的内存分布式处理引擎，可让您以分布式方式高效地处理数据。</li>\n<li>在 PySpark 上运行的应用程序比传统系统快 100 倍。</li>\n<li>使用 PySpark 进行数据摄取管道将给您带来巨大的好处。</li>\n<li>使用 PySpark，我们可以处理来自 Hadoop HDFS、AWS S3 和许多文件系统的数据。</li>\n<li>PySpark 还用于使用 Streaming 和 Kafka 处理实时数据。</li>\n<li>使用 PySpark 流式传输，您还可以从文件系统流式传输文件，也可以从套接字流式传输。</li>\n<li>PySpark 本身具有机器学习和图形库。</li>\n</ol>\n<h2 id=\"_2-什么是apache-spark\" tabindex=\"-1\"> 2. 什么是Apache Spark</h2>\n<p><code>Apache Spark</code>是一个用于大规模数据处理的开源统一分析引擎，以下简称Spark。Spark 被设计为快速、灵活且易于使用，使其成为处理大规模数据集的流行选择。Spark 对分布式集群上数十亿和数万亿数据的运行速度比传统应用程序快 100 倍。</p>\n<p>Spark可以运行在 单节点机器或多节点机器（集群）上。它的创建是为了 通过进行内存处理来解决MapReduce 的局限性。Spark 通过使用内存缓存来重用数据，以加速在同一数据集上重复调用函数的机器学习算法。这降低了延迟，使 Spark 比 MapReduce 快数倍，特别是在进行机器学习和交互式分析时。Apache Spark 还可以处理实时流。</p>\n<p>它也是一个 多语言引擎， 为 <code>Java</code>、<code>Scala</code>、<code>Python</code> 和 <code>R</code> 等多种编程语言提供 API（应用程序编程接口）和库，允许开发人员使用他们最熟悉的语言来使用 <code>Spark</code>。</p>\n<ul>\n<li>Scala：  Spark 的主要语言和母语是 Scala。Spark的许多核心组件都是用Scala编写的，它为Spark提供了最广泛的API。</li>\n<li>Java：  Spark 提供了 Java API，允许开发人员在 Java 应用程序中使用 Spark。Java 开发人员可以通过此 API 访问 Spark 的大部分功能。</li>\n<li>Python：  Spark 提供了一个名为 PySpark 的 Python API，它在喜欢使用 Python 进行数据分析和机器学习任务的数据科学家和开发人员中很受欢迎。PySpark 提供了一种与 Spark 交互的 Pythonic 方式。</li>\n<li>R：  Spark 还提供 R API，使 R 用户能够使用 Spark 数据并使用他们熟悉的 R 语言执行分布式数据分析。</li>\n</ul>\n<h2 id=\"_3-pyspark-架构\" tabindex=\"-1\"> 3. PySpark 架构</h2>\n<div>\n<p>pyspark架构</p>\n<p>Apache Spark 在主从架构中工作，其中主设备称为“Driver”，从设备称为“Workers”。当您运行 Spark 应用程序时，Spark Driver会创建一个上下文作为应用程序的入口点，所有操作（转换和操作）都在工作节点上执行，资源由 Cluster Manager 管理。</p>\n</div>\n<figure><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepress/2024-02-02-sk1NgN.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n",
      "image": "https://img.tucang.cc/api/image/show/498496728f8ad787045c66c3af161ab1",
      "date_published": "2024-02-01T00:00:00.000Z",
      "date_modified": "2024-02-02T08:44:35.000Z",
      "authors": [
        {
          "name": "梁贺祥"
        }
      ],
      "tags": [
        "技术",
        "IT"
      ]
    },
    {
      "title": "📖理解SparkSession",
      "url": "https://lianghexiang.github.io/space/posts/pyspark/SparkSession%E6%95%99%E7%A8%8B.html",
      "id": "https://lianghexiang.github.io/space/posts/pyspark/SparkSession%E6%95%99%E7%A8%8B.html",
      "content_html": "<p>🔖 自 Spark 2.0 起，SparkSession 已成为 PySpark 与 RDD 和 DataFrame 配合使用的入口点。在2.0之前，入口点曾是SparkContext。 本节内容将主要通过定义和描述如何创建 SparkSession 以及使用-shellspark中的默认 SparkSession 变量来重点解释什么是 SparkSession........</p>\n\n<h1 id=\"理解sparksession\" tabindex=\"-1\"> 📖理解SparkSession</h1>\n<h2 id=\"sparksession\" tabindex=\"-1\"> 1️⃣SparkSession</h2>\n<p>✏️在Spark2.0版本，pyspark.sql引入了一个新类<code>SparkSession</code>。SparkSession 是我们在 2.0 版本之前使用的所有不同上下文（SQLContext 和 HiveContext 等）的组合类。从 2.0 开始，SparkSession 可以用来替换 SQLContext、HiveContext 以及 2.0 之前定义的其他上下文。<br>\n✏️正如开头提到的，SparkSession 是 PySpark 的入口点，创建 SparkSession 实例将是您使用 RDD、DataFrame 和 Dataset 进行编程时编写的第一个语句。<br>\n✏️虽然 SparkContext 在 2.0 之前曾经是一个入口点，但并没有完全被 SparkSession 取代。SparkContext 的许多功能在 Spark 2.0 及更高版本中仍然可用，而且SparkSession是在内部创建了<code>SparkConfig </code>和<code>SparkContext</code>，并通过<code>SparkSession</code>来提供配置创建。</p>\n<p>SparkSession还包括其他不同上下文的API：</p>\n<ul>\n<li>SparkContext,</li>\n<li>SQLContext,</li>\n<li>StreamingContext,</li>\n<li>HiveContext.</li>\n</ul>\n<p>❓ PySpark程序中可以创建多少个SparkSession？</p>\n<pre><code>可以创建多个SparkSession。如果想要PySpark表在逻辑上分离时，就需要使用`SparkSession.builder()`或者`SparkSession.newSession()`创建多个SparkSession\n</code></pre>\n<h2 id=\"创建sparksession\" tabindex=\"-1\"> 2️⃣创建SparkSession</h2>\n<p>在PySpark程序中，需要使用构造器方法builder方法。builder方法的使用方法如下：</p>\n<div data-ext=\"py\"><pre><code><span># Create SparkSession from builder</span>\n<span>import</span> pyspark\n<span>from</span> pyspark<span>.</span>sql <span>import</span> SparkSession\nspark <span>=</span> SparkSession<span>.</span>builder<span>.</span>master<span>(</span><span>\"local[1]\"</span><span>)</span> \\\n                    <span>.</span>appName<span>(</span><span>'SparkByExamples.com'</span><span>)</span> \\\n                    <span>.</span>getOrCreate<span>(</span><span>)</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>\n<li><code>master()</code>: 如果是在集群上运行程序，需要使用主机名称为参数传入master()。这个参数值通常是<code>yarn</code>或者是<code>mesos</code>，这取决于你的主节点的配置。</li>\n<li><code>local[num]</code>: 在单机模式下运行的时候使用。<code>num</code>应该是一个整数值，表示的是在使用<code>RDD</code>、<code>DataFrame</code>、<code>DataSet</code>时应该创建多少个分区。一般这个值可以是CPU核心数。</li>\n<li><code>appName()</code>: 设置应用名称</li>\n<li><code>getOrCreate()</code>: 从名字即可看出，获取或者创建SparkSession，如果已经存在则获取，否则创建新的SparkSession</li>\n</ul>\n<p><strong>创建另一个SparkSession：</strong></p>\n<div data-ext=\"py\"><pre><code><span># Create new SparkSession</span>\nspark2 <span>=</span> SparkSession<span>.</span>newSession\n<span>print</span><span>(</span>spark2<span>)</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><blockquote>\n<p>使用上面的代码会创建一个新的SparkSession，并且与现有的SparkSession使用相同的应用名称。两个会话的底层 SparkContext 是相同的，因为每个 PySpark 应用程序只能有一个上下文。</p>\n</blockquote>\n<p><strong>获取现有的SparkSession</strong></p>\n<div data-ext=\"py\"><pre><code><span># Get Existing SparkSession</span>\nspark3 <span>=</span> SparkSession<span>.</span>builder<span>.</span>getOrCreate\n<span>print</span><span>(</span>spark3<span>)</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><h2 id=\"使用-spark-配置\" tabindex=\"-1\"> 3️⃣使用 Spark 配置</h2>\n<p>可以使用<code>config</code>方法为SparkSession增加配置</p>\n<div data-ext=\"py\"><pre><code><span># 使用 config()</span>\nspark <span>=</span> SparkSession<span>.</span>builder \n      <span>.</span>master<span>(</span><span>\"local[1]\"</span><span>)</span> \n      <span>.</span>appName<span>(</span><span>\"SparkByExamples.com\"</span><span>)</span> \n      <span>.</span>config<span>(</span><span>\"spark.some.config.option\"</span><span>,</span> <span>\"config-value\"</span><span>)</span> \n      <span>.</span>getOrCreate<span>(</span><span>)</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"创建启用hive的sparksession\" tabindex=\"-1\"> 4️⃣ 创建启用Hive的SparkSession</h2>\n<blockquote>\n<p>为了将 Hive 与 PySpark 一起使用，您需要使用该enableHiveSupport()方法启用它。</p>\n</blockquote>\n<div data-ext=\"py\"><pre><code>spark <span>=</span> SparkSession<span>.</span>builder \\\n      <span>.</span>master<span>(</span><span>\"local[1]\"</span><span>)</span> \\\n      <span>.</span>appName<span>(</span><span>\"SparkByExamples.com\"</span><span>)</span> \\\n      <span>.</span>config<span>(</span><span>\"spark.sql.warehouse.dir\"</span><span>,</span> <span>\"&lt;path>/spark-warehouse\"</span><span>)</span> \\\n      <span>.</span>enableHiveSupport<span>(</span><span>)</span> \\\n      <span>.</span>getOrCreate<span>(</span><span>)</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"获取或配置pyspark-config\" tabindex=\"-1\"> 5️⃣ 获取或配置PySpark Config</h2>\n<blockquote>\n<p>创建 SparkSession 后，您可以在运行时添加 Spark 配置或获取所有配置。</p>\n</blockquote>\n<div data-ext=\"py\"><pre><code><span># Set Config</span>\nspark<span>.</span>conf<span>.</span><span>set</span><span>(</span><span>\"spark.executor.memory\"</span><span>,</span> <span>\"5g\"</span><span>)</span>\n\n<span># Get a Spark Config</span>\npartitions <span>=</span> spark<span>.</span>conf<span>.</span>get<span>(</span><span>\"spark.sql.shuffle.partitions\"</span><span>)</span>\n<span>print</span><span>(</span>partitions<span>)</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"简单创建dataframe\" tabindex=\"-1\"> 6️⃣ 简单创建DataFrame</h2>\n<p>使用<code>createDataFrame</code>创建DataFrame</p>\n<div data-ext=\"py\"><pre><code><span># Create DataFrame</span>\ndf <span>=</span> spark<span>.</span>createDataFrame<span>(</span>\n    <span>[</span><span>(</span><span>\"Scala\"</span><span>,</span> <span>25000</span><span>)</span><span>,</span> <span>(</span><span>\"Spark\"</span><span>,</span> <span>35000</span><span>)</span><span>,</span> <span>(</span><span>\"PHP\"</span><span>,</span> <span>21000</span><span>)</span><span>]</span><span>)</span>\ndf<span>.</span>show<span>(</span><span>)</span>\n\n<span># Output</span>\n<span>#+-----+-----+</span>\n<span>#|   _1|   _2|</span>\n<span>#+-----+-----+</span>\n<span>#|Scala|25000|</span>\n<span>#|Spark|35000|</span>\n<span>#|  PHP|21000|</span>\n<span>#+-----+-----+</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>🔗 <a href='https://sparkbyexamples.com/pyspark/different-ways-to-create-dataframe-in-pyspark/'>其他创建DataFrame的方法</a></p>\n<p>、</p>\n",
      "image": "https://img.tucang.cc/api/image/show/da3546c26f3726a1f7a63e96921b30ff",
      "date_published": "2024-02-01T00:00:00.000Z",
      "date_modified": "2024-03-20T09:26:16.000Z",
      "authors": [
        {
          "name": "梁贺祥"
        }
      ],
      "tags": [
        "技术",
        "IT"
      ]
    },
    {
      "title": "PicgoGitHub图床",
      "url": "https://lianghexiang.github.io/space/posts/tools/PicgoGitHub%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A.html",
      "id": "https://lianghexiang.github.io/space/posts/tools/PicgoGitHub%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A.html",
      "content_html": "<h1 id=\"picgogithub图床\" tabindex=\"-1\"> PicgoGitHub图床</h1>\n<h2 id=\"前言\" tabindex=\"-1\"> 前言</h2>\n<p>这篇文章主要介绍在💻<code>windows</code>系统下安装PicGo并且在🇬🇭  GitHub上创建仓库来做我们自己的个人图床。</p>\n<p>首先，什么是 <code>Picgo</code>？</p>\n<p>picgo网站地址：<a href=\"https://picgo.github.io/PicGo-Doc/zh/guide/#%E7%89%B9%E8%89%B2%E5%8A%9F%E8%83%BD\" target=\"_blank\" rel=\"noopener noreferrer\">https://picgo.github.io/PicGo-Doc/zh/guide/#特色功能</a></p>\n<p><strong>PicGo: 一个用于快速上传图片并获取图片 URL 链接的工具</strong></p>\n<p>呈上GitHub下载地址：<a href=\"https://github.com/Molunerfinn/PicGo/releases\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/Molunerfinn/PicGo/releases</a></p>\n<p>也可以在picgo网站中找到各种下载原，比如GitHub的，腾讯的，以及别的源，哪个快用哪个。</p>\n<p><strong>应用截图</strong></p>\n<figure><img src=\"https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picgo-2.0.gif\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<p>GitHub想必就不用做过多介绍了，一句话概括就是一个在线的代码托管平台。</p>\n<p>Picgo支持很多的图床，比如七牛云，腾讯云等，这里我们介绍的是免费的GitHub。</p>\n<h2 id=\"动手\" tabindex=\"-1\"> 动手</h2>\n<h3 id=\"_1-安装picgo\" tabindex=\"-1\"> 1. 安装Picgo</h3>\n<p>我选择的是2.4.0.beta版本，大家安装的时候可以选择稳定版，看个人喜好，喜欢尝试新功能的可以按照beta版，偏向于稳定的就安装稳定版。</p>\n<p>2.3.1稳定版：<a href=\"https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.1\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.1</a></p>\n<figure><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepressimage-20230729151038685.png\" alt=\"image-20230729151038685\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20230729151038685</figcaption></figure>\n<p>其余的安装过程不再赘述，因为没什么特别需要注意的地方，傻瓜式安装就可以了，不想安装在C盘的注意更改安装目录。</p>\n<h3 id=\"_2-github仓库\" tabindex=\"-1\"> 2. GitHub仓库</h3>\n<ol>\n<li>先登录GitHub，点击  + ，点击创建仓库</li>\n</ol>\n<figure><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepressimage-20230729164849247.png\" alt=\"image-20230729164849247\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20230729164849247</figcaption></figure>\n<ol start=\"2\">\n<li>\n<p>创建仓库前配置好<code>名称</code>，<code>权限</code>，模板等，因为我们要在网络上访问，所以要选择<code>Public</code>.</p>\n<figure><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepressimage-20230729164838764.png\" alt=\"image-20230729164838764\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20230729164838764</figcaption></figure>\n</li>\n</ol>\n<p>​\t创建成功后会跳转到仓库页面</p>\n<figure><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepressimage-20230729164829442.png\" alt=\"image-20230729164829442\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20230729164829442</figcaption></figure>\n<ol start=\"3\">\n<li>\n<p>生成token</p>\n<p>token是用来验证用户身份的表示，所以要自己揣兜里，不要让别人看到。</p>\n<p>点击右上角的头像</p>\n<figure><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepressimage-20230729164813237.png\" alt=\"image-20230729164813237\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20230729164813237</figcaption></figure>\n<p>然后点击Settings</p>\n<figure><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepressimage-20230729164803602.png\" alt=\"image-20230729164803602\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20230729164803602</figcaption></figure>\n<p>在左侧导航栏的最下方找到<code>Developer settings</code>,然后点击，-&gt;</p>\n</li>\n</ol>\n<figure><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepressimage-20230729164654737.png\" alt=\"image-20230729164654737\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20230729164654737</figcaption></figure>\n<p>跳转到如下页面-&gt;</p>\n<figure><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepressimage-20230729152822569.png\" alt=\"image-20230729152822569\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20230729152822569</figcaption></figure>\n<p>然后，设置过期时间，权限等 -&gt;</p>\n<figure><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepressimage-20230729164637962.png\" alt=\"image-20230729164637962\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20230729164637962</figcaption></figure>\n<p>最后，划到页面最底部，点击生成token：*************</p>\n<figure><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepressimage-20230729153248698.png\" alt=\"image-20230729153248698\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20230729153248698</figcaption></figure>\n<p><strong>注意:这个token只能查看一次，如果离开这个页面在返回就看不到了, 所以先保存好token</strong></p>\n<h3 id=\"_3-配置picgo\" tabindex=\"-1\"> 3.  🛠️配置PicGo</h3>\n<p>打开PicGo</p>\n<p>点击图床设置，我们可以看到GitHub</p>\n<figure><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepressimage-20230729155924896.png\" alt=\"image-20230729155924896\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20230729155924896</figcaption></figure>\n<p>1️⃣：图床配置名</p>\n<blockquote>\n<p>可以自己随便命名</p>\n</blockquote>\n<p>2️⃣: 设置仓库名</p>\n<blockquote>\n<p>用户名/仓库名</p>\n</blockquote>\n<p>3️⃣:设置分支名</p>\n<blockquote>\n<p>一般都为main</p>\n</blockquote>\n<p>4️⃣: 设置token</p>\n<blockquote>\n<p>这里就要用到我们之前创建仓库之后设置的token了，将它填进去即可</p>\n</blockquote>\n<p>5️⃣: 设置存储路径</p>\n<blockquote>\n<p>默认的话会上传的仓库的根目录，也就是/，如果我们想要上传到仓库的某个目录下，就需要填写目录名称，并且以/结尾</p>\n<p>比如我想上传到仓库下的blog目录下，这里就填写<code>blog/</code></p>\n</blockquote>\n<p>6️⃣: 设置自定义域名</p>\n<blockquote>\n<p>我这里没有用到自定义域名，如果读者有需要的话可以问问度娘</p>\n</blockquote>\n<p>配置完之后，在上传区选中GitHub</p>\n<figure><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepressimage-20230729162854239.png\" alt=\"image-20230729162854239\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20230729162854239</figcaption></figure>\n<p>到此Picgo和GitHub的图床已经配置完成了，接下来就可以快乐的将图片上传到GitHub，然后获取到链接，在远程来访问我们的图片啦。</p>\n<h3 id=\"_4-typora\" tabindex=\"-1\"> 4. Typora</h3>\n<p>另外，经常使用Typora的小伙伴也可以通过Typora的偏好设置来将我们本地的图片通过PicGo来自动上传到仓库中啦</p>\n<ol>\n<li>点开Typora导航栏中的文件</li>\n</ol>\n<figure><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepressimage-20230729163642417.png\" alt=\"image-20230729163642417\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20230729163642417</figcaption></figure>\n<ol start=\"2\">\n<li>\n<p>在偏好设置中配置PicGo</p>\n<figure><img src=\"https://raw.githubusercontent.com/lianghexiang/picgo-picture/main/vuepressimage-20230729164404631.png\" alt=\"image-20230729164404631\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20230729164404631</figcaption></figure>\n</li>\n</ol>\n",
      "image": "https://img.tucang.cc/api/image/show/3f96a1fd6956f27e1badccf6d7f982e1",
      "date_published": "2023-07-14T00:00:00.000Z",
      "date_modified": "2024-01-28T09:53:16.000Z",
      "authors": [],
      "tags": [
        "工具"
      ]
    },
    {
      "title": "Vue基础知识",
      "url": "https://lianghexiang.github.io/space/posts/Vue/Vue%E5%9F%BA%E7%A1%80.html",
      "id": "https://lianghexiang.github.io/space/posts/Vue/Vue%E5%9F%BA%E7%A1%80.html",
      "content_html": "<h1 id=\"vue基础知识\" tabindex=\"-1\"> Vue基础知识</h1>\n<h3 id=\"指令系统\" tabindex=\"-1\"> 指令系统</h3>\n<ol>\n<li>v-text</li>\n<li>v-html</li>\n<li>v-show</li>\n<li>v-if</li>\n<li>v-model 双向数据绑定</li>\n</ol>\n<h3 id=\"常用属性\" tabindex=\"-1\"> 常用属性</h3>\n<ol>\n<li>data()</li>\n<li>el</li>\n<li>methods</li>\n<li>watch</li>\n<li>computed</li>\n<li>templates</li>\n</ol>\n<h3 id=\"vue组件\" tabindex=\"-1\"> Vue组件</h3>\n<h4 id=\"全局组件\" tabindex=\"-1\"> 全局组件</h4>\n<p><strong>用法</strong>：</p>\n<div data-ext=\"text\"><pre><code>Vue.component(\"组件的名字\", {属性：})\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><h4 id=\"局部组件\" tabindex=\"-1\"> 局部组件</h4>\n<ol>\n<li>声明子组件</li>\n<li>挂载子组件</li>\n<li>使用子组件</li>\n</ol>\n<h3 id=\"组件传值\" tabindex=\"-1\"> 组件传值</h3>\n<h4 id=\"_1-父组件-子组件\" tabindex=\"-1\"> 1. 父组件 --&gt;  子组件</h4>\n<h4 id=\"_2-子组件-父组件\" tabindex=\"-1\"> 2. 子组件  --&gt; 父组件</h4>\n<h4 id=\"_3-平行组件传值\" tabindex=\"-1\"> 3. 平行组件传值</h4>\n<h3 id=\"生命周期钩子函数\" tabindex=\"-1\"> 生命周期钩子函数</h3>\n<ul>\n<li>beforeCreate</li>\n<li>created  重点\n<ul>\n<li>组件创建</li>\n<li>虚拟DOM</li>\n<li>发送ajax，获取数据，实现数据驱动视图</li>\n</ul>\n</li>\n<li>beforeMount</li>\n<li>mounted  重点\n<ul>\n<li>获取真实DOM</li>\n</ul>\n</li>\n<li>beforeUpdate</li>\n<li>updated</li>\n<li>activated</li>\n<li>deactivated</li>\n<li></li>\n</ul>\n<h3 id=\"组件的缓存\" tabindex=\"-1\"> 组件的缓存</h3>\n<h4 id=\"内置组件标签\" tabindex=\"-1\"> 内置组件标签</h4>\n<p>缓存组件</p>\n<div data-ext=\"html\"><pre><code><span>&lt;!--当组件在被切换后需要保存样式时--></span>\n<span><span><span>&lt;</span>keep-alive</span><span>></span></span> 需要被缓存的组件 <span><span><span>&lt;/</span>keep-alive</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><h3 id=\"vue的全家桶-vue-vue-router-vuex\" tabindex=\"-1\"> Vue的全家桶（Vue+Vue-router+Vuex）</h3>\n<h4 id=\"spa-single-page-application\" tabindex=\"-1\"> SPA（Single Page Application）</h4>\n<h3 id=\"vue-router\" tabindex=\"-1\"> Vue-router</h3>\n<p>安装：</p>\n<ol>\n<li>CDN引入：\n<ol>\n<li>vue-2.0： <a href=\"https://unpkg.com/vue-router@2.0.0/dist/vue-router.js\" target=\"_blank\" rel=\"noopener noreferrer\">https://unpkg.com/vue-router@2.0.0/dist/vue-router.js</a></li>\n<li>vue-3.0： <a href=\"https://unpkg.com/vue-router@4.0.15/dist/vue-router.global.js%E3%80%82\" target=\"_blank\" rel=\"noopener noreferrer\">https://unpkg.com/vue-router@4.0.15/dist/vue-router.global.js。</a></li>\n</ol>\n</li>\n<li>文件引入</li>\n</ol>\n<blockquote>\n<p>VUe的核心插件<br>\n文档参考：<a href=\"https://router.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener noreferrer\">https://router.vuejs.org/zh/</a></p>\n</blockquote>\n<div data-ext=\"html\"><pre><code> Vue Router 是 Vue.js 的官方路由。它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用变得轻而易举。功能包括：  \n● 嵌套路由映射\n● 动态路由选择\n● 模块化、基于组件的路由配置\n● 路由参数、查询、通配符\n● 展示由 Vue.js 的过渡系统提供的过渡效果\n● 细致的导航控制\n● 自动激活 CSS 类的链接\n● HTML5 history 模式或 hash 模式\n● 可定制的滚动行为\n● URL 的正确编码\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id=\"_1-定义组件\" tabindex=\"-1\"> 1. 定义组件</h4>\n<p>在页面中定义路由组件，在路由规则中进行映射</p>\n<h4 id=\"_2-定义路由\" tabindex=\"-1\"> 2. 定义路由</h4>\n<div data-ext=\"js\"><pre><code>\n<span>routes</span><span>:</span><span>[</span>\n  <span>{</span>\n    <span>path</span><span>:</span> <span>\"/home\"</span><span>,</span>\n    <span>component</span><span>:</span> Home\n  <span>}</span><span>,</span>\n  <span>{</span>\n    <span>path</span><span>:</span> <span>'/course'</span><span>,</span>\n    <span>component</span><span>:</span> Course\n  <span>}</span>\n<span>]</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id=\"_3-创建路由实例\" tabindex=\"-1\"> 3. 创建路由实例</h4>\n<div data-ext=\"js\"><pre><code><span>const</span> router <span>=</span> <span>new</span> <span>VueRouter</span><span>(</span><span>{</span>\n<span>}</span><span>)</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><h4 id=\"_4-挂载路由实例到根实例\" tabindex=\"-1\"> 4. 挂载路由实例到根实例</h4>\n<div data-ext=\"js\"><pre><code><span>new</span> <span>Vue</span><span>(</span><span>{</span>\n        <span>el</span><span>:</span> <span>\"#app\"</span><span>,</span>\n        <span>// 挂载路由</span>\n        <span>router</span><span>:</span> router<span>,</span>\n        <span>data</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>{</span>\n\n            <span>}</span><span>;</span>\n        <span>}</span><span>,</span>\n        <span>template</span><span>:</span> <span><span>`</span><span>&lt;App>&lt;/App></span><span>`</span></span><span>,</span>\n        <span>components</span><span>:</span> <span>{</span>\n            App\n        <span>}</span>\n    <span>}</span><span>)</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol>\n<li>全局组件：router-link\n<ol>\n<li>使用 router-link 组件来导航.</li>\n<li>通过传入 <code>to</code> 属性指定链接.</li>\n<li>router-link 默认会被渲染成一个 <code>&lt;a&gt;</code> 标签</li>\n</ol>\n</li>\n</ol>\n<div data-ext=\"html\"><pre><code># 触发原生的click事件\n<span><span><span>&lt;</span>router-link</span> <span>:to</span><span><span>=</span><span>'</span>/<span>'</span></span> <span>@click.native</span><span><span>=</span><span>'</span>function<span>'</span></span><span>></span></span>  \n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><ol start=\"2\">\n<li>全局组件：router-view</li>\n</ol>\n<div data-ext=\"html\"><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>app<span>\"</span></span><span>></span></span>\n<span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>\"</span>../js/vue.js<span>\"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>\"</span>vue-router.js<span>\"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n    <span>const</span> Home <span>=</span> <span>{</span>\n        <span>data</span><span>:</span> <span>function</span><span>(</span><span>)</span><span>{</span>\n            <span>return</span> <span>{</span>\n\n            <span>}</span><span>;</span>\n        <span>}</span><span>,</span>\n        <span>template</span><span>:</span> <span><span>`</span><span>&lt;div>这是首页&lt;/div></span><span>`</span></span><span>,</span>\n    <span>}</span><span>;</span>\n    <span>const</span> Course <span>=</span> <span>{</span>\n        <span>data</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>{</span>\n\n            <span>}</span><span>;</span>\n        <span>}</span><span>,</span>\n        <span>template</span><span>:</span> <span><span>`</span><span>&lt;div>课程列表&lt;/div></span><span>`</span></span><span>,</span>\n    <span>}</span><span>;</span>\n    <span>//创建路由规则</span>\n    <span>const</span> routes <span>=</span> <span>[</span>\n        <span>{</span>\n            <span>path</span><span>:</span> <span>\"/home\"</span><span>,</span>\n            <span>component</span><span>:</span> Home\n        <span>}</span><span>,</span>\n        <span>{</span>\n            <span>path</span><span>:</span> <span>'/course'</span><span>,</span>\n            <span>component</span><span>:</span> Course\n        <span>}</span>\n    <span>]</span><span>;</span>\n    <span>// 定义路由</span>\n    <span>const</span> router <span>=</span> <span>new</span> <span>VueRouter</span><span>(</span><span>{</span>\n        <span>// 缩写</span>\n        <span>// routes</span>\n        <span>routes</span><span>:</span> routes<span>,</span>\n    <span>}</span><span>)</span>\n\n\n\n    <span>let</span> App <span>=</span> <span>{</span>\n        <span>data</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>{</span><span>}</span><span>;</span>\n        <span>}</span><span>,</span>\n        <span>// router-view 路由组件出口</span>\n        <span>template</span><span>:</span> <span><span>`</span><span>\n            &lt;div>\n                &lt;div>\n                    &lt;router-link to=\"/home\">首页&lt;/router-link>\n                    &lt;router-link to=\"/course\">课程&lt;/router-link>\n                &lt;/div>\n                &lt;router-view>&lt;/router-view>\n\n            &lt;/div></span><span>`</span></span><span>,</span>\n    <span>}</span><span>;</span>\n    <span>new</span> <span>Vue</span><span>(</span><span>{</span>\n        <span>el</span><span>:</span> <span>\"#app\"</span><span>,</span>\n        <span>// 挂载路由</span>\n        <span>router</span><span>:</span> router<span>,</span>\n        <span>data</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>{</span>\n\n            <span>}</span><span>;</span>\n        <span>}</span><span>,</span>\n        <span>template</span><span>:</span> <span><span>`</span><span>&lt;App>&lt;/App></span><span>`</span></span><span>,</span>\n        <span>components</span><span>:</span> <span>{</span>\n            App\n        <span>}</span>\n    <span>}</span><span>)</span>\n\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id=\"_5-命名路由\" tabindex=\"-1\"> 5. 命名路由</h4>\n<ol>\n<li>在路由规则中添加<code>name</code>属性</li>\n</ol>\n<div data-ext=\"html\"><pre><code>path: \"/home\",\n// 命名路由\nname: \"Home\",\ncomponent: Home\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><ol start=\"2\">\n<li>在router-link中绑定</li>\n</ol>\n<div data-ext=\"html\"><pre><code><span><span><span>&lt;</span>router-link</span> <span>:to</span><span><span>=</span><span>\"</span>{'name': 'Home'}<span>\"</span></span><span>></span></span>首页<span><span><span>&lt;/</span>router-link</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><h4 id=\"_6-动态路由\" tabindex=\"-1\"> 6.动态路由</h4>\n<ol>\n<li>路由规则</li>\n</ol>\n<div data-ext=\"js\"><pre><code> <span>routes</span><span>:</span> <span>[</span>\n    <span>// 动态路径参数 以冒号开头</span>\n   <span>// 在路由中设置的参数都会被添加到$route.params中，$route.params.id</span>\n    <span>{</span> <span>path</span><span>:</span> <span>'/user/:id'</span><span>,</span> <span>component</span><span>:</span> User <span>}</span>\n  <span>]</span>\n<span>// 可以在路由中设置多个参数，都会被</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><table username:=\"\" tom,=\"\" post_id:=\"\" 123=\"\">\n<thead>\n<tr>\n<th>模式</th>\n<th>匹配路径</th>\n<th>$route.params</th>\n</tr>\n</thead>\n<tbody>\n<tr username:=\"\" tom=\"\">\n<td>/user/:username</td>\n<td>/user/tom</td>\n<td></td>\n</tr>\n<tr>\n<td>/user/:username/post/:post_id</td>\n<td>/user/tom/post/123</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ol start=\"2\">\n<li>响应路由参数的变化</li>\n</ol>\n<blockquote>\n<p>当使用路由参数时，<code>符合相同路由规则的导航</code>，例如从 /user/foo 导航到 /user/bar，<strong>原来的组件实例会被复用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子不会再被调用</strong>。</p>\n</blockquote>\n<p>使用watch属性，监测路由的变化</p>\n<div data-ext=\"js\"><pre><code><span>// 动态路由试例</span>\n    <span>const</span> User <span>=</span> <span>{</span>\n        <span>data</span><span>(</span><span>)</span><span>{</span>\n            <span>return</span> <span>{</span><span>}</span><span>;</span>\n        <span>}</span><span>,</span>\n        <span>template</span><span>:</span> <span><span>`</span><span>&lt;div>&lt;p>用户ID：{{$route.params.id}}&lt;/p>&lt;/div></span><span>`</span></span><span>,</span>\n        <span>// 由于组件被复用，钩子函数只会调用一次</span>\n        <span>created</span><span>(</span><span>)</span><span>{</span>\n            console<span>.</span><span>log</span><span>(</span><span>\"组件被创建\"</span><span>)</span>\n        <span>}</span><span>,</span>\n        <span>// 使用watch监听路由变化或者beforeRouteUpdate 导航守卫</span>\n        <span>watch</span><span>:</span> <span>{</span>\n            <span>$route</span><span>(</span><span>to<span>,</span> <span>from</span></span><span>)</span> <span>{</span>\n                console<span>.</span><span>log</span><span>(</span>to<span>)</span>\n                console<span>.</span><span>log</span><span>(</span>from<span>)</span>\n                <span>// 跳转到首页</span>\n                <span>// 编程式跳转</span>\n                <span>// this.$router.push({path:'/home'})  // 可以加入对象</span>\n                <span>this</span><span>.</span>$router<span>.</span><span>push</span><span>(</span><span>{</span><span>name</span><span>:</span><span>'Home'</span><span>}</span><span>)</span>  <span>// 可以加入对象</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>",
      "image": "https://img.tucang.cc/api/image/show/6c8acb93bd0fc9dd85006746d572df8f",
      "date_published": "2024-01-03T00:00:00.000Z",
      "date_modified": "2024-01-25T08:12:29.000Z",
      "authors": [],
      "tags": [
        "Vue"
      ]
    },
    {
      "title": "Vue客户端",
      "url": "https://lianghexiang.github.io/space/posts/Vue/vue%E5%AE%A2%E6%88%B7%E7%AB%AF.html",
      "id": "https://lianghexiang.github.io/space/posts/Vue/vue%E5%AE%A2%E6%88%B7%E7%AB%AF.html",
      "content_html": "<h1 id=\"vue客户端\" tabindex=\"-1\"> Vue客户端</h1>\n<h3 id=\"_1-什么是webpack\" tabindex=\"-1\"> 1. 什么是webpack</h3>\n<blockquote>\n<p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的_静态模块打包器(module bundler)<em>。当 webpack 处理应用程序时，它会递归地构建一个_依赖关系图(dependency graph)</em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em>。</p>\n</blockquote>\n<figure><img src=\"https://cdn.nlark.com/yuque/0/2022/png/21881466/1657857178273-f17c0225-7be9-470a-b14a-3fdaebbcc194.png#clientId=u946fd131-c234-4&amp;from=paste&amp;height=319&amp;id=u62fb1adf&amp;originHeight=588&amp;originWidth=1125&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=60942&amp;status=done&amp;style=none&amp;taskId=ua4fd9b52-4a29-4fc7-8637-ff6a4daecd2&amp;title=&amp;width=610.1666870117188\" alt=\"图片.png\" tabindex=\"0\" loading=\"lazy\"><figcaption>图片.png</figcaption></figure>\n<h3 id=\"_2-安装webpack\" tabindex=\"-1\"> 2. 安装webpack</h3>\n<div data-ext=\"sh\"><pre><code>PS C:<span>\\</span>Users<span>\\</span>Administrator<span>></span> <span>npm</span> i webpack@3.12.0 <span>-g</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><h3 id=\"diy脚手架\" tabindex=\"-1\"> DIY脚手架</h3>\n<h4 id=\"_1-cmd规范\" tabindex=\"-1\"> 1. cmd规范</h4>\n<ol>\n<li>抛出：module.exports = xxx</li>\n<li>引用：require(相对路径)</li>\n</ol>\n<h4 id=\"_2-es6-module\" tabindex=\"-1\"> 2. ES6  module</h4>\n<div data-ext=\"js\"><pre><code><span>var</span> person<span>;</span>\nperson <span>=</span> <span>{</span>\n    <span>name</span><span>:</span> <span>\"Tom\"</span><span>,</span>\n    <span>age</span><span>:</span> <span>20</span><span>,</span>\n    <span>action</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n        console<span>.</span><span>log</span><span>(</span><span>\"吃饭\"</span><span>)</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n<span>var</span> text <span>=</span> <span>\"测试webpack\"</span><span>;</span>\n\n<span>// 抛出变量</span>\n<span>export</span> <span>{</span>text<span>}</span><span>;</span>\n<span>// 抛出对象</span>\n<span>export</span> <span>default</span> person<span>;</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><figure><img src=\"https://cdn.nlark.com/yuque/0/2022/png/21881466/1657861083761-d7c826f4-dd52-46ef-a417-ad22bbfbe9e8.png#clientId=u946fd131-c234-4&amp;from=paste&amp;height=513&amp;id=u5882659e&amp;originHeight=560&amp;originWidth=729&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=65714&amp;status=done&amp;style=none&amp;taskId=u11e2c40e-49fc-42e7-9d89-ce8d762efdd&amp;title=&amp;width=668.25\" alt=\"图片.png\" tabindex=\"0\" loading=\"lazy\"><figcaption>图片.png</figcaption></figure>\n<div data-ext=\"js\"><pre><code><span>// 引入</span>\n<span>// as x 起变量名，避免冲突</span>\n<span>import</span> <span>*</span> <span>as</span> c <span>from</span> <span>'./module'</span>\n\nconsole<span>.</span><span>log</span><span>(</span>c<span>.</span>text<span>)</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div data-ext=\"html\"><pre><code><span><span><span>&lt;</span>body</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>app<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>\"</span>./main.js<span>\"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n<span><span><span>&lt;/</span>body</span><span>></span></span>\n<span><span><span>&lt;/</span>html</span><span>></span></span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/21881466/1657861203034-2540a3cd-9b91-4e2a-a042-bea3f9c48bec.png#clientId=u946fd131-c234-4&amp;from=paste&amp;height=73&amp;id=u1c14d7f7&amp;originHeight=80&amp;originWidth=600&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=5254&amp;status=done&amp;style=none&amp;taskId=ud2b3a6cc-34d1-4b29-a4db-355a332deef&amp;title=&amp;width=550\" alt=\"图片.png\" loading=\"lazy\">Uncaught SyntaxError: Cannot use import statement outside a module<br>\n使用webpack支持模块化</p>\n<div data-ext=\"sh\"><pre><code>E:<span>\\</span>giteePython<span>\\</span>FrontEndStudy<span>\\</span>Vue<span>\\</span>Day-04<span>\\</span>webpack模块化支持<span>></span>webpack ./main.js ./bundle.js\nHash: 245a451e490b2734bb12\nVersion: webpack <span>3.12</span>.0\nTime: 35ms\nAsset     Size  Chunks             Chunk Names\nbundle.js  <span>3.29</span> kB       <span>0</span>  <span>[</span>emitted<span>]</span>  main\n<span>[</span><span>0</span><span>]</span> ./main.js <span>102</span> bytes <span>{</span><span>0</span><span>}</span> <span>[</span>built<span>]</span>\n<span>[</span><span>1</span><span>]</span> ./module.js <span>231</span> bytes <span>{</span><span>0</span><span>}</span> <span>[</span>built<span>]</span>\n\nE:<span>\\</span>giteePython<span>\\</span>FrontEndStudy<span>\\</span>Vue<span>\\</span>Day-04<span>\\</span>webpack模块化支持<span>></span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div data-ext=\"html\"><pre><code><span><span><span>&lt;</span>body</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>\"</span>app<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span>&lt;!--&lt;script src=\"./main.js\">&lt;/script>--></span>\n  <span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>\"</span>./bundle.js<span>\"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n<span><span><span>&lt;/</span>body</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><figure><img src=\"https://cdn.nlark.com/yuque/0/2022/png/21881466/1657861702777-25715e43-c31c-4eaf-979d-66df157632fc.png#clientId=u946fd131-c234-4&amp;from=paste&amp;height=195&amp;id=u23ac1549&amp;originHeight=213&amp;originWidth=948&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=19351&amp;status=done&amp;style=none&amp;taskId=u403cd069-6124-47c6-882f-47c49a184cf&amp;title=&amp;width=869.0000000000001\" alt=\"图片.png\" tabindex=\"0\" loading=\"lazy\"><figcaption>图片.png</figcaption></figure>\n<h3 id=\"vue-cli3脚手架的使用\" tabindex=\"-1\"> vue-cli3脚手架的使用</h3>\n<p>CLI (@vue/cli) 是一个全局安装的 npm 包，提供了终端里的 vue 命令。它可以通过 vue create 快速搭建一个新项<br>\n目，或者直接通过 vue serve 构建新想法的原型。你也可以通过 vue ui 通过一套图形化界面管理你的所有项目 。</p>\n<h4 id=\"安装\" tabindex=\"-1\"> 安装</h4>\n<blockquote>\n<p>关于旧版本<br>\nVue CLI 的包名称由 vue-cli 改成了 @vue/cli。 如果你已经全局安装了旧版本的 vue-cli (1.x 或 2.x)，你需要先通过 npm uninstall vue-cli -g 或 yarn global remove vue-cli 卸载它。</p>\n</blockquote>\n<div data-ext=\"sh\"><pre><code><span>npm</span> <span>install</span> <span>-g</span> @vue/cli\n<span># OR</span>\n<span>yarn</span> global <span>add</span> @vue/cli\n\n\nC:<span>\\</span>Users<span>\\</span>Administrator<span>></span>npm <span>install</span> <span>-g</span> @vue/cli\n<span>npm</span> WARN config global <span><span>`</span><span>--global</span><span>`</span></span>, <span><span>`</span><span>--local</span><span>`</span></span> are deprecated. Use <span><span>`</span><span>--location</span><span>=</span>global<span>`</span></span> instead.\n<span>npm</span> WARN config global <span><span>`</span><span>--global</span><span>`</span></span>, <span><span>`</span><span>--local</span><span>`</span></span> are deprecated. Use <span><span>`</span><span>--location</span><span>=</span>global<span>`</span></span> instead.\n<span>[</span><span>######............] \\ idealTree:tar-stream: timing idealTree:node_modules/@vue/cli/node_modules/tar-stream Completed i</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"拉取-2-x-模板-旧版本\" tabindex=\"-1\"> 拉取 2.x 模板 (旧版本)</h3>\n<blockquote>\n<p>Vue CLI &gt;= 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具：</p>\n</blockquote>\n<div data-ext=\"sh\"><pre><code><span>npm</span> <span>install</span> <span>-g</span> @vue/cli-init\n<span># `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同</span>\nvue init webpack my-project\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><h3 id=\"使用vue-cli-2-x-创建项目\" tabindex=\"-1\"> 使用vue-cli 2.x 创建项目</h3>\n<h4 id=\"使用webpack-simple创建项目\" tabindex=\"-1\"> 使用webpack-simple创建项目</h4>\n<ol>\n<li>命令 vue init webpack-simple my_project</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/21881466/1657869331955-239fb974-451e-4de8-a1ee-42dba3f75bbc.png#clientId=ud5ec8b75-3503-4&amp;from=paste&amp;height=273&amp;id=ub2c2bf4b&amp;originHeight=298&amp;originWidth=851&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=35001&amp;status=done&amp;style=none&amp;taskId=u4a9fa155-412f-4b57-a54e-83ae75fb6e0&amp;title=&amp;width=780.0833333333334\" alt=\"图片.png\" loading=\"lazy\">\t2. 文件结构：<br>\n<img src=\"https://cdn.nlark.com/yuque/0/2022/png/21881466/1657877155012-41ce1a56-74e1-4678-9474-40f6bc9e0090.png#clientId=ud5ec8b75-3503-4&amp;from=paste&amp;height=215&amp;id=u94af56a3&amp;originHeight=234&amp;originWidth=340&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11108&amp;status=done&amp;style=none&amp;taskId=u72b74c6b-deb1-499c-900c-f579d448499&amp;title=&amp;width=311.6666666666667\" alt=\"图片.png\" loading=\"lazy\"></p>\n<h4 id=\"使用webpack创建项目\" tabindex=\"-1\"> 使用webpack创建项目</h4>\n<ol>\n<li>命令： vue init webpack 项目名</li>\n<li>文件结构</li>\n<li><img src=\"https://cdn.nlark.com/yuque/0/2022/png/21881466/1657877049097-09fc14a3-19c5-4340-9995-41c162349ac3.png#clientId=ud5ec8b75-3503-4&amp;from=paste&amp;height=265&amp;id=u7419ccb5&amp;originHeight=289&amp;originWidth=370&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=12570&amp;status=done&amp;style=none&amp;taskId=u4b961330-dca6-4a24-9c7c-b9817fdf9ec&amp;title=&amp;width=339.1666666666667\" alt=\"图片.png\" tabindex=\"0\" loading=\"lazy\"><figcaption>图片.png</figcaption></li>\n</ol>\n<h3 id=\"启动\" tabindex=\"-1\"> 启动</h3>\n<div data-ext=\"sh\"><pre><code><span>npm</span> run dev\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/21881466/1657870143085-8bcae05a-269c-4618-ac4f-1c28323a59d1.png#clientId=ud5ec8b75-3503-4&amp;from=paste&amp;height=583&amp;id=ud188b8ce&amp;originHeight=636&amp;originWidth=1394&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=145703&amp;status=done&amp;style=none&amp;taskId=u34001fa6-9ea9-49e1-a0fe-041e6bbc693&amp;title=&amp;width=1277.8333333333335\" alt=\"图片.png\" loading=\"lazy\">###  安装vue-router</p>\n<div data-ext=\"sh\"><pre><code><span>npm</span> <span>install</span> vue-router <span>-S</span>  // 局部安装vue-router\n// 安装报错的话指定版本安装\n<span>npm</span> <span>install</span> vue-router@2.0.0 <span>-S</span> \n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><blockquote>\n<p>在引入文件时，index.js可以省略不写</p>\n</blockquote>\n<h3 id=\"webpack\" tabindex=\"-1\"> webpack</h3>\n<h4 id=\"_1-entry\" tabindex=\"-1\"> 1. entry</h4>\n<blockquote>\n<p>项目的入口文件, (main.js或者index.js)</p>\n</blockquote>\n<h4 id=\"_2-output\" tabindex=\"-1\"> 2. output</h4>\n<blockquote>\n<p>输出出口</p>\n</blockquote>\n<h4 id=\"_3-loading\" tabindex=\"-1\"> 3. loading</h4>\n<blockquote>\n<p>babel-loader: 对es6代码的解析<br>\ncss-loader：css代码解析<br>\nstyle-loader：将css代码添加一个style标签插入到header中</p>\n</blockquote>\n",
      "image": "https://img.tucang.cc/api/image/show/6c8acb93bd0fc9dd85006746d572df8f",
      "date_published": "2024-01-25T00:00:00.000Z",
      "date_modified": "2024-01-25T08:20:38.000Z",
      "authors": [],
      "tags": [
        "Vue"
      ]
    },
    {
      "title": "gPRC服务",
      "url": "https://lianghexiang.github.io/space/posts/gRPC/gRPC%E6%9C%8D%E5%8A%A1.html",
      "id": "https://lianghexiang.github.io/space/posts/gRPC/gRPC%E6%9C%8D%E5%8A%A1.html",
      "content_html": "<h1 id=\"gprc服务\" tabindex=\"-1\"> gPRC服务</h1>\n",
      "image": "https://img.tucang.cc/api/image/show/3f96a1fd6956f27e1badccf6d7f982e1",
      "date_published": "2024-01-03T00:00:00.000Z",
      "date_modified": "2024-11-29T07:02:46.000Z",
      "authors": [],
      "tags": [
        "技术"
      ]
    },
    {
      "title": "Linux配置环境变量",
      "url": "https://lianghexiang.github.io/space/posts/Linux/Linux%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.html",
      "id": "https://lianghexiang.github.io/space/posts/Linux/Linux%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.html",
      "content_html": "<h1 id=\"linux配置环境变量\" tabindex=\"-1\"> Linux配置环境变量</h1>\n<h3 id=\"_1-查看所有变量\" tabindex=\"-1\"> 1. 查看所有变量</h3>\n<div data-ext=\"sh\"><pre><code><span># 使用env</span>\nlianghexiang@ubuntu:~$ <span>env</span> \n\n<span># 使用export</span>\nlianghexiang@ubuntu:~$ <span>export</span> \n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"_2-查看一个变量\" tabindex=\"-1\"> 2. 查看一个变量</h3>\n<div data-ext=\"sh\"><pre><code>lianghexiang@ubuntu:~$ <span>echo</span> <span>${变量名}</span>\n<span># 或者</span>\nlianghexiang@ubuntu:~$ <span>env</span> <span>|</span> <span>grep</span> 变量名\n<span># 或者</span>\nlianghexiang@ubuntu:~$ <span>export</span> <span>|</span> <span>grep</span> 变量名\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"_3-设置变量\" tabindex=\"-1\"> 3. 设置变量</h3>\n<h4 id=\"_1-临时设置\" tabindex=\"-1\"> 1. 临时设置</h4>\n<div data-ext=\"sh\"><pre><code><span># 执行export 这个设置仅限当前终端有效，窗口关闭后无效</span>\n<span># 其中PATH变量定义了运行命令的查找路径，以冒号:分割不同的路径，如，/home/yan/share/usr/local/arm/3.4.1/bin 这个就表示一个软件的路径了，多个软件就用:分开，如 /usr/local/LAMP/php/bin:/usr/local/LAMP/mysql/bin</span>\nlianghexiang@ubuntu:~$ <span>export</span> <span><span>PATH</span></span><span>=</span><span>$PATH</span>:路径\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><h4 id=\"_2-当前登录用户的全局变量\" tabindex=\"-1\"> 2. 当前登录用户的全局变量</h4>\n<div data-ext=\"sh\"><pre><code><span># 修改.bashrc文件</span>\n<span>vim</span> ~/.bashrc\n<span># 在该文件末尾添加如下行 path是要添加的变量的路径</span>\n<span>export</span> <span><span>PATH</span></span><span>=</span>path:<span>$PATH</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"_3-测试\" tabindex=\"-1\"> 3. 测试</h3>\n<div data-ext=\"sh\"><pre><code><span># 执行查看命令</span>\n<span>echo</span> <span>$PATH</span>\n<span># 或者</span>\n<span>env</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div>",
      "image": "https://img.tucang.cc/api/image/show/64a50296cae6612fb1468ddb15110c75",
      "date_published": "2023-07-28T00:00:00.000Z",
      "date_modified": "2024-11-29T07:02:46.000Z",
      "authors": [],
      "tags": [
        "技术"
      ]
    },
    {
      "title": "Mysql知识积累",
      "url": "https://lianghexiang.github.io/space/posts/mysql/mysql%E5%A4%87%E5%BF%98%E5%BD%95.html",
      "id": "https://lianghexiang.github.io/space/posts/mysql/mysql%E5%A4%87%E5%BF%98%E5%BD%95.html",
      "content_html": "<h1 id=\"mysql知识积累\" tabindex=\"-1\"> Mysql知识积累</h1>\n<h3 id=\"_1-mysql内置函数\" tabindex=\"-1\"> 1. Mysql内置函数</h3>\n<h4 id=\"_1-instr\" tabindex=\"-1\"> 1. instr</h4>\n<p>简介：</p>\n<blockquote>\n<p>函数返回字符串中子字符串第一次出现的位置.如果在str中找不到子字符串，则INSTR()函数返回零(0)</p>\n</blockquote>\n<p>使用场景：</p>\n<blockquote>\n<p>想要在字符串中查找子字符串或检查字符串中是否存在子字符串。</p>\n</blockquote>\n<p>函数语法:</p>\n<div data-ext=\"sql\"><pre><code>INSTR<span>(</span>str<span>,</span>substr<span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p><code>INSTR</code>函数接受两个参数：<strong>str</strong>是要搜索的字符串,<strong>substr</strong>是要搜索的子字符串。</p>\n<h4 id=\"_2-substr\" tabindex=\"-1\"> 2. substr</h4>\n<p>简介：</p>\n<blockquote>\n<p>substr从字符串中提取特定长度的子字符串</p>\n</blockquote>\n<p>使用场景：</p>\n<blockquote>\n<p>想要通过索引截取字符串的一部分。</p>\n</blockquote>\n<p>函数语法：</p>\n<div data-ext=\"sql\"><pre><code>substr<span>(</span>string string<span>,</span>num <span>start</span><span>,</span>num length<span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>string为字符串；start为起始位置；length为长度。</p>\n<p>⚠️start是从1开始的</p>\n<h4 id=\"_3-case-when的用法\" tabindex=\"-1\"> 3. CASE.....WHEN的用法</h4>\n<h3 id=\"_2-查询\" tabindex=\"-1\"> 2. 查询</h3>\n<h4 id=\"_1-1子查询\" tabindex=\"-1\"> 1. 1子查询</h4>\n<p>子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从MySQL 4.1开始引入</p>\n<h5 id=\"子查询操作符\" tabindex=\"-1\"> 子查询操作符</h5>\n<ol>\n<li>\n<p>ANY（SOME）</p>\n<blockquote>\n<p>ANY和SOME关键字是同义词，表示满足其中任一条件，它们允许创建一个表达式对子查询的返回值列表进行比较，只要满足内层子查询中的任何一个比较条件，就返回一个结果作为外层查询的条件</p>\n</blockquote>\n<figure><img src=\"https://cdn.nlark.com/yuque/0/2023/png/21881466/1680257852246-b1c2996b-aa6e-4079-a290-d35c23b2515c.png\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n</li>\n<li>\n<p>ALL</p>\n<blockquote>\n<p>ALL关键字与ANY和SOME不同，使用ALL时需要同时满足所有内层查询的条件。</p>\n</blockquote>\n<figure><img src=\"https://cdn.nlark.com/yuque/0/2023/png/21881466/1680257896133-1033c011-39b3-4270-8244-2afdd83a4d38.png\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n</li>\n<li>\n<p>IN</p>\n<blockquote>\n<p>IN关键字进行子查询时，内层查询语句仅仅返回一个数据列，这个数据列里的值将提供给外层查询语句进行比较操作。</p>\n</blockquote>\n<figure><img src=\"https://cdn.nlark.com/yuque/0/2023/png/21881466/1680258121818-4baff6c0-ea14-4415-9f9f-7e5a590379f5.png\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n</li>\n<li>\n<p>EXISTS</p>\n<blockquote>\n<p>EXISTS关键字后面的参数是一个任意的子查询，系统对子查询进行运算以判断它是否返回行，如果至少返回一行，那么EXISTS的结果为true，此时外层查询语句将进行查询；如果子查询没有返回任何行，那么EXISTS返回的结果是false，此时外层语句将不进行查询。</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"_2-2-regexp的用法\" tabindex=\"-1\"> 2.2 <code>REGEXP</code>的用法</h4>\n<p>REGEXP 是用于进行正则表达式匹配的运算符。</p>\n<p>**<code>like</code><strong>关键字可以进行模糊匹配，Mysql同样也支持正则表达式的匹配，Mysql中使用</strong><code>REGEXP</code><strong>和</strong><code>RLIKE</code>**操作符来进行正则表达式匹配。</p>\n<p>可用于**<code>REGEXP</code>**的正则模式:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">模式</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">^</td>\n<td style=\"text-align:left\">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\\n' 或 '\\r' 之后的位置。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$</td>\n<td style=\"text-align:left\">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\\n' 或 '\\r' 之前的位置。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">.</td>\n<td style=\"text-align:left\">匹配除 &quot;\\n&quot; 之外的任何单个字符。要匹配包括 '\\n' 在内的任何字符，请使用像 '[.\\n]' 的模式。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[...]</td>\n<td style=\"text-align:left\">字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 &quot;plain&quot; 中的 'a'。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[^...]</td>\n<td style=\"text-align:left\">负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 &quot;plain&quot; 中的'p'。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">p1|p2|p3</td>\n<td style=\"text-align:left\">匹配 p1 或 p2 或 p3。例如，'z|food' 能匹配 &quot;z&quot; 或 &quot;food&quot;。'(z|f)ood' 则匹配 &quot;zood&quot; 或 &quot;food&quot;。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">*</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或多次。例如，zo* 能匹配 &quot;z&quot; 以及 &quot;zoo&quot;。* 等价于{0,}。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+</td>\n<td style=\"text-align:left\">匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 &quot;zo&quot; 以及 &quot;zoo&quot;，但不能匹配 &quot;z&quot;。+ 等价于 {1,}。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\" n=\"\"></td>\n<td style=\"text-align:left\">n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 &quot;Bob&quot; 中的 'o'，但是能匹配 &quot;food&quot; 中的两个 o。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\" n,m=\"\"></td>\n<td style=\"text-align:left\">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。</td>\n</tr>\n</tbody>\n</table>\n<p>💁‍♂️ 复习一下正则表达式的字符类吧：</p>\n<ul>\n<li><code>.</code>：匹配任意单个字符。</li>\n<li><code>^</code>：匹配字符串的开始。</li>\n<li><code>$</code>：匹配字符串的结束。</li>\n<li><code>*</code>：匹配零个或多个前面的元素。</li>\n<li><code>+</code>：匹配一个或多个前面的元素。</li>\n<li><code>?</code>：匹配零个或一个前面的元素。</li>\n<li><code>[abc]</code>：匹配字符集中的任意一个字符。</li>\n<li><code>[^abc]</code>：匹配除了字符集中的任意一个字符以外的字符。</li>\n<li><code>[a-z]</code>：匹配范围内的任意一个小写字母。</li>\n<li><code>\\d</code>：匹配一个数字字符。</li>\n<li><code>\\w</code>：匹配一个字母数字字符（包括下划线）。</li>\n<li><code>\\s</code>：匹配一个空白字符。</li>\n</ul>\n<p>下面我们从几个案例来学习一下**<code>REGEXP</code>**的基本使用：</p>\n<div data-ext=\"sql\"><pre><code><span>SELECT</span> column1<span>,</span> column2<span>,</span> <span>.</span><span>.</span><span>.</span>\n<span>FROM</span> table_name\n<span>WHERE</span> column_name <span>REGEXP</span> <span>'pattern'</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p><strong>参数说明：</strong></p>\n<ul>\n<li><code>column1</code>, <code>column2</code>, ... 是你要选择的列的名称，如果使用 <code>*</code> 表示选择所有列。</li>\n<li><code>table_name</code> 是你要从中查询数据的表的名称。</li>\n<li><code>column_name</code> 是你要进行正则表达式匹配的列的名称。</li>\n<li><code>'pattern'</code> 是一个正则表达式模式。</li>\n</ul>\n<ol>\n<li><strong>查找 name 字段中以 'st' 为开头的所有数据：</strong></li>\n</ol>\n<div data-ext=\"sql\"><pre><code>mysql<span>></span> <span>SELECT</span> name <span>FROM</span> person_tbl <span>WHERE</span> name <span>REGEXP</span> <span>'^st'</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><ol start=\"2\">\n<li>\n<p><strong>查找 name 字段中以 <strong>'ok'</strong> 为结尾的所有数据：</strong></p>\n<div data-ext=\"sql\"><pre><code>mysql<span>></span> <span>SELECT</span> name <span>FROM</span> person_tbl <span>WHERE</span> name <span>REGEXP</span> <span>'ok$'</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div></li>\n<li>\n<p><strong>查找 name 字段中包含 <strong>'mar'</strong> 字符串的所有数据：</strong></p>\n<div data-ext=\"sql\"><pre><code>mysql<span>></span> <span>SELECT</span> name <span>FROM</span> person_tbl <span>WHERE</span> name <span>REGEXP</span> <span>'mar'</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div></li>\n<li>\n<p>查找 name 字段中以元音字符开头或以 <strong>'ok'</strong> 字符串结尾的所有数据：</p>\n<div data-ext=\"sql\"><pre><code>mysql<span>></span> <span>SELECT</span> name <span>FROM</span> person_tbl <span>WHERE</span> name <span>REGEXP</span> <span>'^[aeiou]|ok$'</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div></li>\n<li>\n<p>选择订单表中描述中包含 &quot;item&quot; 后跟一个或多个数字的记录。</p>\n<div data-ext=\"sql\"><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> orders <span>WHERE</span> order_description <span>REGEXP</span> <span>'item[0-9]+'</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div></li>\n<li>\n<p>使用 <strong>BINARY</strong> 关键字，使得匹配区分大小写：</p>\n<div data-ext=\"sql\"><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> products <span>WHERE</span> product_name <span>REGEXP</span> <span>BINARY</span> <span>'apple'</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div></li>\n<li>\n<p>使用 OR 进行多个匹配条件，以下将选择姓氏为 &quot;Smith&quot; 或 &quot;Johnson&quot; 的员工记录：</p>\n<div data-ext=\"sql\"><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> employees <span>WHERE</span> last_name <span>REGEXP</span> <span>'Smith|Johnson'</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div></li>\n</ol>\n<p><strong>📖</strong> <strong>RLIKE 是 MySQL 中用于进行正则表达式匹配的运算符，与 REGEXP 是一样的，RLIKE 和 REGEXP 可以互换使用，没有区别。</strong></p>\n<h3 id=\"_3-插入\" tabindex=\"-1\"> 3. 插入</h3>\n<h4 id=\"_2-1-ingore\" tabindex=\"-1\"> 2.1 ingore</h4>\n<p>插入数据时，如果数据已经存在，则不再执行插入</p>\n<h3 id=\"_4-修改\" tabindex=\"-1\"> 4. 修改</h3>\n<h3 id=\"_5-删除\" tabindex=\"-1\"> 5. 删除</h3>\n<h3 id=\"_6-存储过程和函数\" tabindex=\"-1\"> 6. 存储过程和函数</h3>\n<h4 id=\"_1-存储过程\" tabindex=\"-1\"> 1. 存储过程</h4>\n<h3 id=\"_7-地理类型\" tabindex=\"-1\"> 7. 地理类型</h3>\n<h5 id=\"_1-使用st-distance-sphere函数计算经纬度距离\" tabindex=\"-1\"> 1. 使用<code>ST_Distance_Sphere</code>函数计算经纬度距离</h5>\n",
      "image": "https://img.tucang.cc/api/image/show/be92f3fc23a4ba0672923f5f05c7e08b",
      "date_published": "2024-01-20T00:00:00.000Z",
      "date_modified": "2024-11-29T07:02:46.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "介绍页",
      "url": "https://lianghexiang.github.io/space/intro.html",
      "id": "https://lianghexiang.github.io/space/intro.html",
      "content_html": "<h1 id=\"介绍页\" tabindex=\"-1\"> 介绍页</h1>\n<p>我所在的位置：中国河南省<br>\n联系方式：<br>\n🐧 QQ：1973749775</p>\n<p>📧邮箱:lhx110396@163.com</p>\n<p>💻目前在郑州工作</p>\n<p>👋 你好！我的介绍页<br>\n既然茫茫人海中你能来到我的个人主页，这也是一种邂逅! ✨</p>\n<p>我热衷于分享最新的科技趋势和创新的编程技巧，致力于让技术变得更加容易理解和应用。我相信技术可以改变世界，而我希望成为这个变革的一部分。🌍💪</p>\n<p>📚 在我的博客中，你将发现我对编程语言、前端开发、人工智能和数据科学等领域的深入研究和经验分享。无论你是初学者还是经验丰富的开发者，我都将为你提供有价值的内容和实用的建议。🎓🚀</p>\n<p>🌱 我认为学习是持续的过程，因此我致力于不断拓展自己的知识和技能。我不仅保持对最新技术的追踪，还乐于探索新的编程范式和工具。我相信通过不断学习和探索，我们可以超越自己的边界并实现令人惊叹的创新。🌈🔍</p>\n<p>🤝 我欢迎与各位读者和同行建立联系，并共同探索技术世界的奇妙之处。如果你对我博客中的任何主题感兴趣，或者想要进行深入讨论，别犹豫，和我联系吧！💌🤗</p>\n<p>✨ 无论你是想了解新技术、解决编程难题还是追求个人成长，我都希望我的博客能够成为你的指南之一。让我们一起在代码的世界中留下印记，一起创造更加美好的未来！🌟</p>\n",
      "image": "https://img.tucang.cc/api/image/show/6c8acb93bd0fc9dd85006746d572df8f",
      "date_published": "2023-07-07T06:08:45.000Z",
      "date_modified": "2023-12-22T00:47:39.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "幻灯片页",
      "url": "https://lianghexiang.github.io/space/slides.html",
      "id": "https://lianghexiang.github.io/space/slides.html",
      "content_html": "\n<Presentation id=\"presentation-1\" code=\"eJzNWV9TGlkWf+dT3DHzoG4ag9mprXJG32ZqaiupfcnDVjlWGrGjrAgWNBlrN5siQUQMCJmoKGIEo5FMFJ2JMfwR+S4zfW93P818hDm3bwMNQYFgJvNAcetyzu/8ueece+7B9NVnHIfMHod9QhhCE1bRyoluq9NjF+0u53CPtt+DOG7EZLp2DeF8UX50JIeC5GxF3i2YdG7BIcwITnEI2RxWj2e4x83ds4ucKMyJOquU80m5H+WsD0dW5cR8A4yUW8axeXk/go+jyskJfvH6V9/jtrFHkFRKKr4Auu02f+uaFcxIOXpHigm8lFHPUiQVhLVSyirlTRzYk3JPQBc1/dZk4jhOs4lSvMlUVWpb7ujv20+DY73XBiwDlj4K1xWaVCrLKxnEg1a8DkKOT3D+TUuoe27rJN1A96wTAmd36oA42Qgg5Q5rUniEFxdw6Gf8/LG8CWQfJqSCVxdEZrOZ/goSkjVHSLkl8q6Il1L4p+fEt9+VnCpTnaRQhEUZ+vbO7VsIB/zySao7qVqEtJUf2r7VK7o4q9M+YxWFasbctrqnJ1zfOzsIhBSOHknFvXrvVY6uggdBfkjeaMmkpQ6EjJI9NrctprlpLUzoVrdrgKaUN8j6UeWobppM8Ku6s64W15XsrnSWUII/QuYqpQMS2ZFyBby7jxc2tHpg5CTJkLzlQ/398s9xqfSsv/86ukvWkrC8ex09fIgXU+rGrlwoP3yIyFoQH8Zx/hSHAzj2Go0yBPXZOVneG+udEsVZz9DAwIx7ihYPOFihD4HqJPtWiZV+OwsDp5RbwVl/VTnQTEmHQScS8oEzwCsknlKTPvIkgMt+oAR2dbWMCy81vT+Jq/FiXElndK/mCoi3Ox12p8CNO1y2aR6UQmo6L29mmyxMFrO+RBbDetCwhmP7NFYlMxQidqRVgyn75JQDPiJUzOgPUvEUx5bhwKTiCzn1CG/Fqwemvl6XClntMHie/4/HZHM5PSKyomFk+ZJu/SXMASFTDZaUUlJ+m4nQMe98/W+4Hs7wWZRtkNVjfPgSBw5gRzPw889N/+z9TpwSROvdG9f1haUPTP3O4525+z/78I3/U6JPY/EviVR/P72f4Xqbj/b3DyGIUmrPD2F2H0HOake4h6NLkF6Q51IuAsJq0ICFgwtMAEimMhYCOJvHW6BIBEfjZOWIhB/pqdd9Bcc5P/7Jd5WF9UOhoeFYQHxtm2eUiMZ59pVe5yCkchHlNICDheoBKWE/3jyhRc0fwAtvoQnCxyU4R8VfgvrabpF6T+3PRm+5Jl1jvQMO+DJ77k9CG3SRKR7RLYi2qQZL9N2KITiXxUuvaD1d3seLp7SRCuzhzXPaKS6uKfsL6s5Tet5wJxxHtfwo07pcPMDp1zgQIMV01WTW15C1PI49hS6AcoUAeUN+VVDjJ+2arO2MW23Tk26X1znB2VwOlxvMmRzv/ceN64h+Br/4os/QIOuu0W46f5hsHBlyRvUllHIQFJJDeZxN1LpgrUVBfIM0aGu0roXWsGxCyodq56khQzpdEN/N43gpI68UqbgsdL9X3yZ8EL6RCQqIVFhmtRqOm6yfq4mYscjQQ9TaOu34wK1w5yovH9FSVN/tIb7S0YEPobJoQpgOnd7I9VbRYzWi0XuU15tGvsPmUmd0ecX2OIGwgdU72x6nd1Zn1Igddrj6xt2CdboejRbX9vAoZYMqDuFem2ZQygZmt3aHt8WtkbZjjd3JwdXnbN+9BoYG9Sq/eIQZe+d4Fa5uE6pp6EGh+L6lOpSoZpJnym13QgfYgomRGdhEt31aaM2mkbU4oGrfxrmFiZaQddQ1hWrbk25BaB25DfTNgMYd3tYW1pO3banN63YDe4cWG7iaKVz5uVMP1PFdBtyhR4xsVxLvuwl4qdXvV29TEg7JgX01XcCFKDztlBf5Ju9/aBACp+TJHvSRzcC+8sxanRcW6hETQs0p6mOS0l1EWS3djAghkotBU4NGEI6uy4UdWNCdYIFhDFAQTa6+qnx350jmJYPzKgMVDaSiLNg8IcxV2g6ykgcVmR/pzauBMiB2/0KzHQuz3/UTgUf5Zg42m5FziCR98KyBa51ODi+PKb0fr1dsuOdmjx6q8sGBVAjTOUAXaIMM7YLcpSLYqKELEZaPofBVPGpozEXXu2wDP6bEO1VsSJRa86wGInIpy3pBxNcU4JHqC8FwAgcy0H8r2XOgog+EyutZb72TmctabyMcywHAUv0ZBkff69qTiUa372yIHqvT5RTgiyY5fGk+uDCgYOZwX5hjC5v1PmX4r8s101Fmd+hENm8LklyapWP9+x1yVX1cNI7jDQ30ezrwMGYvV9O7rsgW9uWVbaMcsrpIniev7gW+tA1u/zODtUOJ1M9s6mQyVR55F4yo2FRHP4OjfHVWBX9PwEzRMKh6r1SPwtvwgY2bGOP16QrZ2qMzk5yfcbHIZoNJfc6FRi3c4IObD/4+ZnII1XkXXY7DcpAtbbDsnYMB0QiyoL+hQfjMfWmy9d7su3Q09rH9qe7MK/uLJJOGwRYMicMwB3qC+K89NvDk4hri/wU5GnkDLjJOopTld/g8Ls+/lB/nSfyU/edjRLrk+fexDdJKU7TRoG90c76xWNo2yIj0CQ2Sz16RlfOaKVYHRHnvLbvTO4egklTi1ia6Hbw2UofSATaAJThYrFoI+1KxKJVWWTGhA3fNCzQ/Yk/J4S7bZ/kB8ioDK7wQIQdpHUzjAH1gLNRYddowBcnFZ2Rr2/QHLsR/vQ==\" theme=\"auto\"></Presentation>",
      "image": "https://img.tucang.cc/api/image/show/72e720a5032441381e8d626f0e6538f1",
      "date_published": "2023-07-07T06:08:45.000Z",
      "date_modified": "2023-07-07T06:08:45.000Z",
      "authors": [],
      "tags": []
    }
  ]
}